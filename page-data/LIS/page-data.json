{"componentChunkName":"component---src-templates-blog-template-js","path":"/LIS/","result":{"data":{"cur":{"id":"670f45ec-4317-5d9d-8b81-ba43c3ebd85a","html":"<h2 id=\"-lis최장-증가-부분-수열\" style=\"position:relative;\"><a href=\"#-lis%EC%B5%9C%EC%9E%A5-%EC%A6%9D%EA%B0%80-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4\" aria-label=\" lis최장 증가 부분 수열 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 LIS(최장 증가 부분 수열)</h2>\n<p>원소의 개수가 N개인 배열이 있다고 가정을 해보자. 배열의 원소 index는 변하지 않는 조건 하에 각 원소가 이전 원소보다 큰, 그 길이가 최대인 부분 수열을 <code class=\"language-text\">최장 증가 부분 수열</code>이라고 한다.</p>\n<h2 id=\"-이분탐색을-활용한-lis\" style=\"position:relative;\"><a href=\"#-%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-lis\" aria-label=\" 이분탐색을 활용한 lis permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 이분탐색을 활용한 LIS</h2>\n<p>LIS 알고리즘을 구현하는 방법은 여러가지가 있지만 <code class=\"language-text\">이분탐색</code>을 이용한 방법은 효율적으로 구현할 수 있다. 일반적으로 이분탐색은 O(logN)에 탐색이 가능하기 때문에 LIS를 구현하는 문제에서는 O(NlogN)의 시간복잡도로 문제를 해결할 수 있다.</p>\n<p><img src=\"/ef8c6e95a2437dc2027780c0dc2dfcf2/1.png\" alt=\"\"></p>\n<p>위 이분탐색을 이용하여 LIS를 구하는 코드는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> inputNumber <span class=\"token operator\">=</span> input<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>Number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> <span class=\"token constant\">LIS</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// LIS 배열에서 인덱스 값보다 작은 값이 나왔을 경우에 실행될 함수</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">BinarySearch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> target</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> mid<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">&lt;</span> right<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    mid <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>left <span class=\"token operator\">+</span> right<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">LIS</span><span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> target<span class=\"token punctuation\">)</span> left <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> right <span class=\"token operator\">=</span> mid<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> right<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token constant\">LIS</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> inputNumber<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// LIS 비교 인덱스</span>\n<span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 원래 배열 비교 인덱스</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> <span class=\"token constant\">N</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">LIS</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> inputNumber<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token constant\">LIS</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> inputNumber<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    j <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> index <span class=\"token operator\">=</span> <span class=\"token function\">BinarySearch</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> inputNumber<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token constant\">LIS</span><span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> inputNumber<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  i <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"-실제-lis에-해당하는-배열-구하기\" style=\"position:relative;\"><a href=\"#-%EC%8B%A4%EC%A0%9C-lis%EC%97%90-%ED%95%B4%EB%8B%B9%ED%95%98%EB%8A%94-%EB%B0%B0%EC%97%B4-%EA%B5%AC%ED%95%98%EA%B8%B0\" aria-label=\" 실제 lis에 해당하는 배열 구하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 실제 LIS에 해당하는 배열 구하기</h2>\n<p>위 방법은 LIS의 길이를 구하는 방법이다. 따라서 실제 해당 길이에 포함되는 배열을 구하고 싶을 때는 추가적인 작업이 필요하다.</p>\n<p><img src=\"/bf577b34e864bb8fa1aad630eeb697ae/2.png\" alt=\"\"></p>\n<p><img src=\"/83648b63fe5abb9cc9a5cc2339b50788/3.png\" alt=\"\"></p>\n<ol>\n<li>\n<p>위에서 살펴봤던 LIS를 구하는 과정처럼 LIS 배열과 Record라는 배열을 생성한 후 LIS 배열에는 기존 과정을, Record라는 배열에는 LIS 몇번 째 배열에 값이 입력되는지 index 값을 순차적으로 적어준다.</p>\n</li>\n<li>\n<p>이후에 한번 순회하게 된다면 Record 배열의 최대값으로부터 거꾸로 순회하며 해당 인덱스에 해당하는 원본 수열의 값을 임시 LIS에 넣어주고 최대값을 1씩 줄여나간다.</p>\n</li>\n<li>\n<p>임시 LIS를 오름차순으로 정렬한다.</p>\n</li>\n<li>\n<p>해당 배열이 실제 LIS에 해당하는 결과값이다.</p>\n</li>\n</ol>\n<h2 id=\"-reference\" style=\"position:relative;\"><a href=\"#-reference\" aria-label=\" reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📑 Reference</h2>\n<p><a href=\"https://yhwan.tistory.com/21\">그림 출처 : 방앗간 개발자</a></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-lis%EC%B5%9C%EC%9E%A5-%EC%A6%9D%EA%B0%80-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4\">🎯 LIS(최장 증가 부분 수열)</a></li>\n<li><a href=\"#-%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-lis\">🎯 이분탐색을 활용한 LIS</a></li>\n<li><a href=\"#-%EC%8B%A4%EC%A0%9C-lis%EC%97%90-%ED%95%B4%EB%8B%B9%ED%95%98%EB%8A%94-%EB%B0%B0%EC%97%B4-%EA%B5%AC%ED%95%98%EA%B8%B0\">🎯 실제 LIS에 해당하는 배열 구하기</a></li>\n<li><a href=\"#-reference\">📑 Reference</a></li>\n</ul>\n</div>","excerpt":"🎯 LIS(최장 증가 부분 수열) 원소의 개수가 N개인 배열이 있다고 가정을 해보자. 배열의 원소 index는 변하지 않는 조건 하에 각 원소가 이전 원소보다 큰, 그 길이가 최대인 부분 수열을 이라고 한다. 🎯 이분탐색을 활용한 LIS LIS 알고리즘을 구현하는 방법은 여러가지가 있지만 을 이용한 방법은 효율적으로 구현할 수 있다. 일반적으로 이분탐색은 O(logN)에 탐색이 가능하기 때문에 LIS를 구현하는 문제에서는 O(NlogN)의 시간복잡도로 문제를 해결할 수 있다.  위 이분탐색을 이용하여 LIS를 구하는 코드는 아래와 같다. 🎯 실제 LIS에 해당하는 배열 구하기 위 방법은 LIS의 길이를 구하는 방법이다. 따라서 실제 해당 길이에 포함되는 배열을 구하고 싶을 때는 추가적인 작업이 필요하다.   위에서 살펴봤던 LIS를 구하는 과정처럼 LIS 배열과 Record라는 배열을 생성한 후 LIS 배열에는 기존 과정을, Record라는 배열에는 LIS 몇번 째 배열에 값이 입…","frontmatter":{"date":"March 28, 2024","title":"알고리즘 준비하기 - LIS","categories":"알고리즘","author":"재오","emoji":"📚"},"fields":{"slug":"/LIS/"}},"next":{"id":"ac546b08-c0fa-5778-b848-be708ba2c37d","html":"<h2 id=\"-알파벳을-사용해야-하는-경우\" style=\"position:relative;\"><a href=\"#-%EC%95%8C%ED%8C%8C%EB%B2%B3%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\" 알파벳을 사용해야 하는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🔠 알파벳을 사용해야 하는 경우</h2>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> set <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">length</span><span class=\"token operator\">:</span> <span class=\"token number\">26</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">v<span class=\"token punctuation\">,</span> i</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> String<span class=\"token punctuation\">.</span><span class=\"token function\">fromCharCode</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">65</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"-js에서-복사본-배열을-만들고-기존-배열을-유지하는-경우\" style=\"position:relative;\"><a href=\"#-js%EC%97%90%EC%84%9C-%EB%B3%B5%EC%82%AC%EB%B3%B8-%EB%B0%B0%EC%97%B4%EC%9D%84-%EB%A7%8C%EB%93%A4%EA%B3%A0-%EA%B8%B0%EC%A1%B4-%EB%B0%B0%EC%97%B4%EC%9D%84-%EC%9C%A0%EC%A7%80%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\" js에서 복사본 배열을 만들고 기존 배열을 유지하는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 JS에서 복사본 배열을 만들고 기존 배열을 유지하는 경우</h2>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> basicSum <span class=\"token operator\">=</span> sumArr<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> sortSum <span class=\"token operator\">=</span> sumArr<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> b <span class=\"token operator\">-</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"-시간초과가-발생할-것-같다면\" style=\"position:relative;\"><a href=\"#-%EC%8B%9C%EA%B0%84%EC%B4%88%EA%B3%BC%EA%B0%80-%EB%B0%9C%EC%83%9D%ED%95%A0-%EA%B2%83-%EA%B0%99%EB%8B%A4%EB%A9%B4\" aria-label=\" 시간초과가 발생할 것 같다면 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>⏰ 시간초과가 발생할 것 같다면…?</h2>\n<p>시간초과가 발생할 것 같다면 코드를 뜯어 고치기보다는 <code class=\"language-text\">SIMPLE</code>하게 생각하는 습관을 갖자.</p>\n<p><strong>특히 이중 반복문 또는 삼중 반복문을 사용해야하는 경우라면 <code class=\"language-text\">Map</code>을 사용하는건 어떨까?</strong></p>\n<p>정말 중요한 포인트이다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-%EC%95%8C%ED%8C%8C%EB%B2%B3%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\">🔠 알파벳을 사용해야 하는 경우</a></li>\n<li><a href=\"#-js%EC%97%90%EC%84%9C-%EB%B3%B5%EC%82%AC%EB%B3%B8-%EB%B0%B0%EC%97%B4%EC%9D%84-%EB%A7%8C%EB%93%A4%EA%B3%A0-%EA%B8%B0%EC%A1%B4-%EB%B0%B0%EC%97%B4%EC%9D%84-%EC%9C%A0%EC%A7%80%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\">💡 JS에서 복사본 배열을 만들고 기존 배열을 유지하는 경우</a></li>\n<li><a href=\"#-%EC%8B%9C%EA%B0%84%EC%B4%88%EA%B3%BC%EA%B0%80-%EB%B0%9C%EC%83%9D%ED%95%A0-%EA%B2%83-%EA%B0%99%EB%8B%A4%EB%A9%B4\">⏰ 시간초과가 발생할 것 같다면…?</a></li>\n</ul>\n</div>","frontmatter":{"date":"March 14, 2024","title":"코딩테스트를 경험해보며 느낀 꿀팁","categories":"알고리즘","author":"재오","emoji":"💡"},"fields":{"slug":"/Tip/"}},"prev":{"id":"6bc77413-fb46-597b-92f8-7bb1cb9c7883","html":"<h2 id=\"️-hsat-자격인증-평가란\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-hsat-%EC%9E%90%EA%B2%A9%EC%9D%B8%EC%A6%9D-%ED%8F%89%EA%B0%80%EB%9E%80\" aria-label=\"️ hsat 자격인증 평가란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✏️ HSAT 자격인증 평가란?</h2>\n<p><code class=\"language-text\">HSAT</code>은 현대자동차그룹 <code class=\"language-text\">Softeer</code>에서 주최하는 코딩테스트 역량검증 평가이다. 보통 1년에 3회정도 평가에 참여할 수 있으며, 문제는 총 2문제, 시험시간은 3시간이다. 2문제 모두를 맞혔을 경우에만 현대자동차 그룹 회사인 현대자동차, 기아, 현대오토에버, 현대모비스, 현대차증권의 코딩테스트를 면제해주는 혜택을 2년간 누릴 수 있다.</p>\n<p><img src=\"/0edf62d3d2ae0de8a6636d92cf56dfa8/1.png\" alt=\"\"></p>\n<p>지원 언어는 생각보다 많으니 위 사진을 참고하면 된다. PCCP와는 다르게 응시료도 받지 않으니 마음 편하게 지원해도 된다.</p>\n<h2 id=\"-준비-과정\" style=\"position:relative;\"><a href=\"#-%EC%A4%80%EB%B9%84-%EA%B3%BC%EC%A0%95\" aria-label=\" 준비 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🐣 준비 과정</h2>\n<p>👉 소프티어 연습문제 풀어보기 : <a href=\"https://softeer.ai/practice?q=%EC%A0%95%EA%B8%B0&#x26;page=1\">Softeer 연습문제</a></p>\n<p><img src=\"/b7e32aaf2bece1c4df38c5f6b8b6328a/2.png\" alt=\"\"></p>\n<p>위 사이트에 들어가면 지금까지 응시했던 HSAT 정기평가 기출문제를 풀어볼 수 있다. 꼭 위 문제를 풀어보길 바란다. 보통 코딩테스트가 프로그래머스에서 이루어지나 HSAT은 Softeer 자체 IDE에서 이뤄지기 때문에 시각적으로(?) 익숙함이 필요하다.\n특히 자바스크립트 기준으로는 프로그래머스에서는 사용하지 않는 <code class=\"language-text\">fs</code> 모듈 입력을 Softeer에서는 백준처럼 다 적어놔야 하기 때문에 직접 적어보는 연습도 중요하다.</p>\n<p>9회 시험을 앞두고 2주정도 기출문제를 풀어봤지만 정말 난이도가 어렵다. 나름 백준 골드 3까지의 문제는 많이 풀어봤는데 소프티어 문제는 체감상 골드1 이상은 되는 것 같다. 스스로의 힘으로 해결한 문제도 얼마 안됐기 때문에 유튜브에 있는 해설영상에 많이 의존했다.</p>\n<p>확실한건 소프티어는 <code class=\"language-text\">DFS</code>와 <code class=\"language-text\">BFS</code>, <code class=\"language-text\">백트래킹</code>을 진짜 좋아한다.</p>\n<h2 id=\"-문제-후기\" style=\"position:relative;\"><a href=\"#-%EB%AC%B8%EC%A0%9C-%ED%9B%84%EA%B8%B0\" aria-label=\" 문제 후기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📄 문제 후기</h2>\n<p>기출문제가 너무 어려워서 별로 기대하지 않고 시험을 응시했다. 그래서인지 긴장감도 없었다. 3시간 시험이기 때문에 여유있게 보고 나오려고 했다.</p>\n<p>시험 보안때문에 구체적으로 문제를 설명할 수 없지만 확실한건 내가 여태 본 코딩테스트 중에서 제일 어려웠다. 그래도 기출문제를 풀면서 면역이 생긴 탓에 당황하지 않은건 좋았던 것 같다.</p>\n<p>1번은 역시 백트래킹. 딱 문제만 봤을 때 스택을 쓰라는 건가 싶었는데, 도저히 스택으로 구현할 자신이 없었다. 그냥 백트래킹으로 구현했고, 테스트 케이스는 한방에 통과했다. 하지만 뭔가 찜찜했기 때문에 2번 풀고 다시 와야지 생각했다. (결과적으로 검토를 못했…흑😭) 1번은 40분 소요됐다.</p>\n<p>2번은 누가봐도 BFS 문제였다. BFS 문제는 연습을 많이 했기 때문에 자신 있었는데 너무 어려워서 놀랐다. 진짜 10분은 멍때린 것 같다. 이걸 어떻게 풀지…?라는 생각이 많이 들었고, 백준에서는 벽 부수고 이동하기인가 그 문제와 유사했지만 훨씬 조건도 까다롭고 어려웠다. 2시간 내내 코드를 썼다 지웠다 하면서 거의 반쯤 포기한 상태였다. 그래도 로직상 답에는 근접한 것 같았는데 30분 넘게 테스트케이스 하나만 통과했다. 대체 뭐가 문제지 싶어서 코드를 다 뜯어봐도 테케가 통과 안되는게 신기했다. 그리고 정확히 종료 5분전에 초기 세팅한 부분에서 잘못됨을 깨닫고 급하게 수정하고 종료 1분전에 테케가 모두 통과됐음을 확인했다. 하지만 이것도 찜찜하다. (뭔가 시간초과 날 것 같은 느낌적인 느낌…ㅎ)</p>\n<p>결론적으로 1,2번 모두 테케는 통과했지만 찜찜하게 끝났다.</p>\n<h2 id=\"-느낀점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80%EC%A0%90\" aria-label=\" 느낀점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🫠 느낀점</h2>\n<p><img src=\"/f29385a4f6c75ffe9dcaf4b52d628939/3.jpg\" alt=\"\"></p>\n<p>최종 결과는 4월 9일에 나온다. 물론 기대는 안하지만 그래도 테케는 다 통과해서 마음은 편하게 기다릴 수 있을 것 같다. 코테 공부를 시작한지 100일 정도 됐는데 아직 백트래킹 문제만 나오면 쫄린다. 이 부분에 대해 꾸준히 연습을 많이 해야한다고 생각이 든다. 백트래킹 마스터가 되고 소프티어 10회 다시 도전!</p>\n<p>끗!</p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EF%B8%8F-hsat-%EC%9E%90%EA%B2%A9%EC%9D%B8%EC%A6%9D-%ED%8F%89%EA%B0%80%EB%9E%80\">✏️ HSAT 자격인증 평가란?</a></li>\n<li><a href=\"#-%EC%A4%80%EB%B9%84-%EA%B3%BC%EC%A0%95\">🐣 준비 과정</a></li>\n<li><a href=\"#-%EB%AC%B8%EC%A0%9C-%ED%9B%84%EA%B8%B0\">📄 문제 후기</a></li>\n<li><a href=\"#-%EB%8A%90%EB%82%80%EC%A0%90\">🫠 느낀점</a></li>\n</ul>\n</div>","frontmatter":{"date":"April 04, 2024","title":"HSAT 자격인증 평가 9회 후기","categories":"알고리즘","author":"재오","emoji":"💡"},"fields":{"slug":"/HSAT/"}},"site":{"siteMetadata":{"siteUrl":"https://www.jaeochoiii.com","comments":{"utterances":{"repo":"jaeochoii/jaeochoii.github.io"}}}}},"pageContext":{"slug":"/LIS/","nextSlug":"/Tip/","prevSlug":"/HSAT/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}