{"componentChunkName":"component---src-templates-blog-template-js","path":"/MapSet/","result":{"data":{"cur":{"id":"95c11caa-a9f2-574d-b232-ec45b604d447","html":"<h2 id=\"-맵\" style=\"position:relative;\"><a href=\"#-%EB%A7%B5\" aria-label=\" 맵 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 맵</h2>\n<p><code class=\"language-text\">Map</code>은 키가 있는 데이터를 저장한다는 점에서 객체와 매우 유사하다. 다만, 객체와 다른 점은 키에 다양한 자료형을 허용한다는 점에서 차이가 있다.</p>\n<p>맵에는 다음과 같은 주요 메서드와 프로퍼티가 있다.</p>\n<ul>\n<li>new Map() : 맵을 생성한다.</li>\n<li>map.set(key, value) : key를 이용해 value를 저장한다.</li>\n<li>map.get(key) : key에 해당하는 값을 반환한다. key가 존재하지 않으면 undefined를 반환한다.</li>\n<li>map.has(key) : key가 존재하면 true, 존재하지 않으면 false를 반환한다.</li>\n<li>map.delete(key) : key에 해당하는 값을 삭제한다.</li>\n<li>map.clear() : 맵 안의 모든 요소를 제거한다.</li>\n<li>map.size() : 요소의 개수를 반환한다.</li>\n</ul>\n<p>주의해야할 점은 map[key]는 Map을 사용하는 올바른 방법이 아니다. 이 방법은 map을 일반 객체처럼 취급하게 된다. 따라서 여러 제약이 생기게 된다. map을 사용할 땐 map 전용 메서드 set, get 등을 사용해야만 한다.</p>\n<h3 id=\"-맵의-요소에-반복-작업하기\" style=\"position:relative;\"><a href=\"#-%EB%A7%B5%EC%9D%98-%EC%9A%94%EC%86%8C%EC%97%90-%EB%B0%98%EB%B3%B5-%EC%9E%91%EC%97%85%ED%95%98%EA%B8%B0\" aria-label=\" 맵의 요소에 반복 작업하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💎 맵의 요소에 반복 작업하기</h3>\n<ul>\n<li>map.keys() : 각 요소의 키를 모은 반복 가능한 객체를 반환한다.</li>\n<li>map.values() : 각 요소의 값을 모은 이터러블 객체를 반환한다.</li>\n<li>map.entries() : 요소의 [키, 값] 을 한 쌍으로 하는 이터러블 객체를 반환한다. <strong>이 이터러블 객체는 for…of 반복문의 기초로 쓰인다.</strong></li>\n</ul>\n<p><strong>맵은 값이 삽입된 순서대로 순회를 실시한다. 객체가 프로퍼티 순서를 기억하지 못하는 것과는 다르다.</strong></p>\n<h3 id=\"-objectfromentries-맵을-객체로-바꾸기\" style=\"position:relative;\"><a href=\"#-objectfromentries-%EB%A7%B5%EC%9D%84-%EA%B0%9D%EC%B2%B4%EB%A1%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0\" aria-label=\" objectfromentries 맵을 객체로 바꾸기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💎 Object.fromEntries: 맵을 객체로 바꾸기</h3>\n<p><code class=\"language-text\">Object.fromEntries</code>를 사용하면 맵을 객체로 바꿀 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">fromEntries</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"-셋\" style=\"position:relative;\"><a href=\"#-%EC%85%8B\" aria-label=\" 셋 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 셋</h2>\n<p>Set은 중복을 허용하지 않는 값을 모아놓은 특별한 컬렉션이다. 셋에 키가 없는 값이 저장된다.</p>\n<ul>\n<li>new Set(iterable) : 셋을 만든다. 이터러블 객체를 전달받으면 그 안의 값을 복사해 셋에 넣어준다.</li>\n<li>set.add(value) : 값을 추가하고 셋 자신을 반환한다.</li>\n<li>set.delete(value) : 값을 제거한다. 호출 시점 내에 값이 있어서 제거에 성공하면 true를, 아니면 false를 반환한다.</li>\n<li>set.has(value) : 셋 내에 값이 존재하면 true, 아니면 false를 반환한다.</li>\n<li>set.cleat() : 셋을 비운다.</li>\n<li>set.size() : 셋에 몇 개의 값이 있는지 세준다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-%EB%A7%B5\">🎯 맵</a></p>\n<ul>\n<li><a href=\"#-%EB%A7%B5%EC%9D%98-%EC%9A%94%EC%86%8C%EC%97%90-%EB%B0%98%EB%B3%B5-%EC%9E%91%EC%97%85%ED%95%98%EA%B8%B0\">💎 맵의 요소에 반복 작업하기</a></li>\n<li><a href=\"#-objectfromentries-%EB%A7%B5%EC%9D%84-%EA%B0%9D%EC%B2%B4%EB%A1%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0\">💎 Object.fromEntries: 맵을 객체로 바꾸기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EC%85%8B\">🎯 셋</a></p>\n</li>\n</ul>\n</div>","excerpt":"🎯 맵 은 키가 있는 데이터를 저장한다는 점에서 객체와 매우 유사하다. 다만, 객체와 다른 점은 키에 다양한 자료형을 허용한다는 점에서 차이가 있다. 맵에는 다음과 같은 주요 메서드와 프로퍼티가 있다. new Map() : 맵을 생성한다. map.set(key, value) : key를 이용해 value를 저장한다. map.get(key) : key에 해당하는 값을 반환한다. key가 존재하지 않으면 undefined를 반환한다. map.has(key) : key가 존재하면 true, 존재하지 않으면 false를 반환한다. map.delete(key) : key에 해당하는 값을 삭제한다. map.clear() : 맵 안의 모든 요소를 제거한다. map.size() : 요소의 개수를 반환한다. 주의해야할 점은 map[key]는 Map을 사용하는 올바른 방법이 아니다. 이 방법은 map을 일반 객체처럼 취급하게 된다. 따라서 여러 제약이 생기게 된다. map을 사용할 땐 map 전용 …","frontmatter":{"date":"December 31, 2023","title":"자바스크립트 정리하기 - Map과 Set","categories":"자바스크립트","author":"재오","emoji":"📙"},"fields":{"slug":"/MapSet/"}},"next":{"id":"53b0dd88-2015-5f8d-8553-b5377120dcf2","html":"<h2 id=\"-우선순위-큐\" style=\"position:relative;\"><a href=\"#-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90\" aria-label=\" 우선순위 큐 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 우선순위 큐</h2>\n<p>우선순위 큐는 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조의 일부이며 데이터를 우선순위에 따라 처리하고 싶을 때 사용한다.</p>\n<h2 id=\"-우선순위-큐의-구현-방법\" style=\"position:relative;\"><a href=\"#-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90%EC%9D%98-%EA%B5%AC%ED%98%84-%EB%B0%A9%EB%B2%95\" aria-label=\" 우선순위 큐의 구현 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 우선순위 큐의 구현 방법</h2>\n<p>크게 2가지로 분류할 수 있다. <code class=\"language-text\">배열</code>로 구현하는 방법과 <code class=\"language-text\">힙</code>으로 구현하는 방법. 우선 <strong>배열로 구현</strong>하는 것은 구현 자체가 간단하다는 장점이 있지만 데이터를 삭제하거나 삽입해야하는 경우 모든 인덱스를 탐색해야 하는 과정이 있기 때문에 시간복잡도가 **O(N)**이 되므로 상대적으로 부족한 성능을 보여준다.</p>\n<p>하지만 힙으로 구현하는 것은 구현 자체에서 난이도가 높지만 시간복잡도가 **O(logN)**이기 때문에 좋은 성능을 보여준다.</p>\n<h2 id=\"-힙의-특징\" style=\"position:relative;\"><a href=\"#-%ED%9E%99%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-label=\" 힙의 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 힙의 특징</h2>\n<p>그렇다면 힙의 특징은 무엇일까?</p>\n<p><img src=\"/b3c3b55c0dc149dadf723a72ca67b8b4/priority.png\" alt=\"\"></p>\n<ul>\n<li>힙은 <strong>완전 이진 트리</strong> 자료구조이다.</li>\n</ul>\n<p>완전 이진 트리란 마지막 레벨을 제외하고 모든 레벨이 모두 채워져있으며, 마지막 레벨의 모든 노드는 가능한 왼쪽에 위치한다. 즉, 루트 노드로부터 시작하여 왼쪽에서 오른쪽 자식 노드 순서대로 데이터가 순차적으로 삽입되는 트리를 의미한다.</p>\n<ul>\n<li>최소 힙</li>\n</ul>\n<p>루트 노드가 가장 작은 값을 가지며 값이 작은 데이터가 우선적으로 제거된다. 최소 힙은 부모 노드가 항상 자식 노드보다 값이 작다.</p>\n<ul>\n<li>최대 힙</li>\n</ul>\n<p>루트 노드가 가장 큰 값을 가지며 값이 큰 데이터가 우선적으로 제거된다. 최대 힙은 부모 노드가 항상 자식 노드보다 값이 크다.</p>\n<ul>\n<li>힙의 인덱스 관계</li>\n</ul>\n<p>좌측 자식 노드의 인덱스: 부모 노드의 인덱스 _ 2\n우측 자식 노드의 인덱스: 부모 노드의 인덱스 _ 2 + 1\n부모 노드의 인덱스: Math.floor(자식 노드의 인덱스 / 2)</p>\n<h2 id=\"최대-힙의-코드-구현-js\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EB%8C%80-%ED%9E%99%EC%9D%98-%EC%BD%94%EB%93%9C-%EA%B5%AC%ED%98%84-js\" aria-label=\"최대 힙의 코드 구현 js permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최대 힙의 코드 구현 (JS)</h2>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MaxHeap</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 이해하기 쉽게 0번째 Index는 null</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">heapPush</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">value</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> currentIndex <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> parentIndex <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>currentIndex <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>parentIndex <span class=\"token operator\">!==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">[</span>parentIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> temp <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">[</span>parentIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">[</span>parentIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">[</span>currentIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">[</span>currentIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n      currentIndex <span class=\"token operator\">=</span> parentIndex<span class=\"token punctuation\">;</span>\n      parentIndex <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>currentIndex <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">heapPop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 루트 노드밖에 없는 경우</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">let</span> returnValue <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> currentIndex <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> leftIndex <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> rightIndex <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">[</span>currentIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">[</span>leftIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">[</span>currentIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">[</span>rightIndex<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> temp <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">[</span>currentIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">[</span>leftIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">[</span>rightIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">[</span>currentIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">[</span>rightIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">[</span>rightIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n        currentIndex <span class=\"token operator\">=</span> rightIndex<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">[</span>currentIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">[</span>leftIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">[</span>leftIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n        currentIndex <span class=\"token operator\">=</span> leftIndex<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      leftIndex <span class=\"token operator\">=</span> currentIndex <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n      rightIndex <span class=\"token operator\">=</span> leftIndex <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> returnValue<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">heapReturn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>heap<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90\">🎯 우선순위 큐</a></li>\n<li><a href=\"#-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90%EC%9D%98-%EA%B5%AC%ED%98%84-%EB%B0%A9%EB%B2%95\">🎯 우선순위 큐의 구현 방법</a></li>\n<li><a href=\"#-%ED%9E%99%EC%9D%98-%ED%8A%B9%EC%A7%95\">🎯 힙의 특징</a></li>\n<li><a href=\"#%EC%B5%9C%EB%8C%80-%ED%9E%99%EC%9D%98-%EC%BD%94%EB%93%9C-%EA%B5%AC%ED%98%84-js\">최대 힙의 코드 구현 (JS)</a></li>\n</ul>\n</div>","frontmatter":{"date":"December 21, 2023","title":"알고리즘 준비하기 - 우선순위 큐","categories":"알고리즘","author":"재오","emoji":"📚"},"fields":{"slug":"/PriorityQueue/"}},"prev":{"id":"3cb14c7c-b7e3-5a44-b6f9-45c4e3ca7b64","html":"<h2 id=\"-다이나믹-프로그래밍-개념\" style=\"position:relative;\"><a href=\"#-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B0%9C%EB%85%90\" aria-label=\" 다이나믹 프로그래밍 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 다이나믹 프로그래밍 개념</h2>\n<p><code class=\"language-text\">DP</code>라고도 불리는 다이나믹 프로그래밍은 명칭과 의미의 상관관계는 없다. 보통 큰 문제를 작은 문제로 나눠서 문제를 해결할 때 이용되는 알고리즘이다.</p>\n<p>사람들에게 익숙한 예시는 피보나치 수열이 있다. 피보나치 수열 역시 <code class=\"language-text\">재귀</code>를 사용하여 수열의 큰 문제를 작은 문제로 나눠서 해결하는 과정이다. 하지만 피보나치 수열과 다이나믹 프로그래밍은 개념적으로 조금 다른 점을 갖는다.</p>\n<h3 id=\"-피보나치-수열의-핵심\" style=\"position:relative;\"><a href=\"#-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98%EC%97%B4%EC%9D%98-%ED%95%B5%EC%8B%AC\" aria-label=\" 피보나치 수열의 핵심 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💎 피보나치 수열의 핵심</h3>\n<ul>\n<li>문제의 크기에 상관 없이 어떤 한 문제의 정답이 일정하다.</li>\n<li>몇번째 피보나치 수를 구하든지에 상관없이 n번째 피보나치수는 항상 동일하다.</li>\n</ul>\n<h3 id=\"-다이나믹-프로그래밍의-핵심\" style=\"position:relative;\"><a href=\"#-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%ED%95%B5%EC%8B%AC\" aria-label=\" 다이나믹 프로그래밍의 핵심 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💎 다이나믹 프로그래밍의 핵심</h3>\n<ul>\n<li>각 작은 문제는 한 번만 풀어야 한다.</li>\n<li>같은 문제는 구할 때마다 정답이 같다.</li>\n<li>정답을 한 번 구했으면, 어딘가에 메모해놓는다.</li>\n<li>메모하는 것을 코드에서는 배열로 구현할 수 있다.</li>\n<li>메모한다고 해서 Memoization이라는 용어를 사용한다.</li>\n</ul>\n<h2 id=\"-다이나믹-프로그래밍-구현\" style=\"position:relative;\"><a href=\"#-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B5%AC%ED%98%84\" aria-label=\" 다이나믹 프로그래밍 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 다이나믹 프로그래밍 구현</h2>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> <span class=\"token function-variable function\">fibo</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">></span> <span class=\"token number\">2</span> <span class=\"token operator\">?</span> <span class=\"token function\">fibo</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fibo</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위는 일반적으로 재귀를 이용하는 피보나치 수의 구현이다. 하지만 결론적으로 피보나치 수열은 이미 계산했던 값을 이용하는 것이라 매우 비효율적이다.</p>\n<p>예를 들어 n의 값으로 5가 들어갔다고 가정해보자. 5번째 피보나치 수를 구하기 위해 4번째, 3번째의 피보나치 수를 구해야 하고 내부 4번째 수를 구하기 위해서는 또 3번째와 2번째의 피보나치 수를 구해야 하고, 3번째 피보나치 수를 구하기 위해 2번째와 1번째의 피보나치 수를 구해야 한다.</p>\n<p>위 단락의 과정은 4번째 피보나치 수를 구한 방식이다. 3번째 피보나치를 구하기위해서 또 3번째 2번째 피보나치 수를 구하고 2번째 1번째 피보나치 수를 구하는, 무한반복의 과정이 이루어진다.</p>\n<p>그래서 아래의 방법을 이용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> fiboArr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> <span class=\"token function-variable function\">fiboWithMemoization</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    fiboArr<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>fiboArr<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    fiboArr<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">fiboWithMemoization</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fiboWithMemoization</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> fiboArr<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위는 DP를 이용한 피보나치 수 구현이다. fiboArr이라는 곳에 내가 계산해둔 피보나치 수를 저장해둔다. 이러한 방식의 차이는 속도면에서 어마어마한 차이를 가져온다. 이를테면 50번째 피보나치 수를 구하는 것은 메모이제이션을 사용하지 않은 단순 재귀에서는 어마어마한 시간이 걸리지만, 메모이제이션을 사용한 피보나치 수 구하기 함수를 이용하면 금방 나온다.</p>\n<h2 id=\"-다이나믹-프로그래밍의-시간복잡도\" style=\"position:relative;\"><a href=\"#-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\" 다이나믹 프로그래밍의 시간복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 다이나믹 프로그래밍의 시간복잡도</h2>\n<p>메모이제이션을 하지 않으면, 대략 O(2n^2) 만큼의 시간복잡도가 걸린다. 하지만 메모이제이션을 하면 대략 O(3n)만큼의 시간에 값을 구하게 된다.</p>\n<h2 id=\"-다이나믹-프로그래밍의-구현-방식\" style=\"position:relative;\"><a href=\"#-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9D\" aria-label=\" 다이나믹 프로그래밍의 구현 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 다이나믹 프로그래밍의 구현 방식</h2>\n<ol>\n<li>\n<p><strong>Top-down</strong>\n큰 문제부터 문제를 쪼개가며 작은 문제로 만들고 다시 합쳐가며 원래 문제를 푸는 방식이다. 위에서 봤던 예제가 <code class=\"language-text\">Top-down</code> 방식이다.</p>\n</li>\n<li>\n<p><strong>Bottom-up</strong>\n작은 문제들을 모아서 큰 문제를 만들어 쌓아 올려가는 방식이다.</p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// bottom-up의 예제</span>\nint d<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nint <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">int n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  d<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  d<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>int i<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span>n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    d<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> d<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> d<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> d<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>설명은 했지만 두 방법 중 하나만 알아도 다이나믹 프로그래밍 문제를 푸는데 큰 지장은 없다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B0%9C%EB%85%90\">🎯 다이나믹 프로그래밍 개념</a></p>\n<ul>\n<li><a href=\"#-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98%EC%97%B4%EC%9D%98-%ED%95%B5%EC%8B%AC\">💎 피보나치 수열의 핵심</a></li>\n<li><a href=\"#-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%ED%95%B5%EC%8B%AC\">💎 다이나믹 프로그래밍의 핵심</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B5%AC%ED%98%84\">🎯 다이나믹 프로그래밍 구현</a></p>\n</li>\n<li>\n<p><a href=\"#-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84\">🎯 다이나믹 프로그래밍의 시간복잡도</a></p>\n</li>\n<li>\n<p><a href=\"#-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9D\">🎯 다이나믹 프로그래밍의 구현 방식</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"January 01, 2024","title":"알고리즘 준비하기 - 다이나믹 프로그래밍","categories":"알고리즘","author":"재오","emoji":"📚"},"fields":{"slug":"/DP/"}},"site":{"siteMetadata":{"siteUrl":"https://www.jaeochoiii.com","comments":{"utterances":{"repo":"jaeochoii/jaeochoii.github.io"}}}}},"pageContext":{"slug":"/MapSet/","nextSlug":"/PriorityQueue/","prevSlug":"/DP/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}