{"componentChunkName":"component---src-templates-blog-template-js","path":"/Greedy/","result":{"data":{"cur":{"id":"016a6a1c-1d34-53ec-9b71-0c2ea3323aae","html":"<h2 id=\"-그리디-알고리즘\" style=\"position:relative;\"><a href=\"#-%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\" 그리디 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 그리디 알고리즘</h2>\n<p>그리디 알고리즘, 즉 <code class=\"language-text\">탐욕법</code>은 말 그대로 선택의 순간마다 눈앞에 보이는 최적의 상황만을 쫓아서 최종적인 해답에 도달하는 방법이다. <code class=\"language-text\">탐욕법</code>을 이용하여 문제를 해결하는 순서는 아래와 같다.</p>\n<ul>\n<li>현재 상태에서의 최적의 해답을 선택한다.</li>\n<li>선택된 해가 문제의 조건을 만족하는지 검사한다.</li>\n<li>원래의 문제가 해결되었는지 체크하고, 해결되지 않았다면 최적의 해답을 찾는 과정으로 돌아가 위의 과정을 반복한다.</li>\n</ul>\n<p><code class=\"language-text\">탐욕법</code>은 문제를 해결하는 과정에서 매 순간 최적이라고 생각되는 해답을 찾으며, 이를 토대로 최종 문제의 해답에 도달하는 문제 해결 방식이다. 하지만 <strong>항상 최적의 결과를 보장하지 못한다는 점을 명심해야 한다.</strong></p>\n<p>따라서 아래와 같이 2가지 조건을 모두 성립하지 못한다면 탐욕법을 사용하면 안된다.</p>\n<ul>\n<li>앞의 선택이 이후의 선택에 영향을 주지 않는다.</li>\n<li>문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 문제 해결 방법으로 구성된다.</li>\n</ul>\n<p><code class=\"language-text\">탐욕법</code>은 항상 최적의 결과를 도출하는 것은 아니지만, 어느 정도 최적에 근사한 값을 빠르게 도출할 수 있는 장접이 있다.</p>\n<h2 id=\"-그리디-알고리즘-예시\" style=\"position:relative;\"><a href=\"#-%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%98%88%EC%8B%9C\" aria-label=\" 그리디 알고리즘 예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 그리디 알고리즘 예시</h2>\n<p>그리디 알고리즘을 사용하여 해결한 백준 코딩테스트 문제를 예로 들어 설명해보자.</p>\n<p><a href=\"https://www.acmicpc.net/problem/11047\">백준 - 동전 0</a></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> input <span class=\"token operator\">=</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFileSync</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/dev/stdin'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">trim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">N</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">MONEY</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> input<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>Number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> pocket <span class=\"token operator\">=</span> input<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">-</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>Number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>pocket<span class=\"token punctuation\">.</span>length <span class=\"token operator\">!==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span><span class=\"token constant\">MONEY</span> <span class=\"token operator\">/</span> pocket<span class=\"token punctuation\">[</span>pocket<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> pocket<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    count <span class=\"token operator\">+=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span><span class=\"token constant\">MONEY</span> <span class=\"token operator\">/</span> pocket<span class=\"token punctuation\">[</span>pocket<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token constant\">MONEY</span> <span class=\"token operator\">=</span> <span class=\"token constant\">MONEY</span> <span class=\"token operator\">%</span> pocket<span class=\"token punctuation\">[</span>pocket<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    pocket<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>여러 문제를 풀어본 결과 그리디 알고리즘에서 중요한 것은 <strong>배열의 정렬</strong>이다. 위 문제도 마찬가지로 배열을 오름차순으로 정렬한 후 해결하는 것이 수월하다. 배열의 가장 끝에 있는 값(MAX 값)으로 돈을 나눈다. 만약 몫이 0이라면 배열 가장 끝에 있는 값을 pop하면 된다. pop연산은 시간복잡도가 O(1)이기 때문에 신경쓰지 않아도 된다.</p>\n<p>이후에 몫이 있다면 그 몫을 count에 더해주고 나머지 값을 새로운 MONEY로 대체한다. 이후에 다시 배열 끝에 있는 값을 pop하는 과정을 배열의 길이가 0이될 때까지 반복한다.</p>\n<h2 id=\"-정리\" style=\"position:relative;\"><a href=\"#-%EC%A0%95%EB%A6%AC\" aria-label=\" 정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 정리</h2>\n<p>코딩테스트 고수분들의 블로그 글을 살펴보니 보통 <strong>그리디 알고리즘 -> 다이나믹 프로그래밍 -> 그래프</strong> 순서대로 문제를 해결한다고 한다. 일단 그리디 알고리즘이 아닐까? 생각하고 접근을 해보고 아닌 것 같으면 점화식을 찾는 DP, 최종적으로 그래프를 이용해 문제를 해결하면 된다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">🎯 그리디 알고리즘</a></li>\n<li><a href=\"#-%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%98%88%EC%8B%9C\">🎯 그리디 알고리즘 예시</a></li>\n<li><a href=\"#-%EC%A0%95%EB%A6%AC\">🎯 정리</a></li>\n</ul>\n</div>","excerpt":"🎯 그리디 알고리즘 그리디 알고리즘, 즉 은 말 그대로 선택의 순간마다 눈앞에 보이는 최적의 상황만을 쫓아서 최종적인 해답에 도달하는 방법이다. 을 이용하여 문제를 해결하는 순서는 아래와 같다. 현재 상태에서의 최적의 해답을 선택한다. 선택된 해가 문제의 조건을 만족하는지 검사한다. 원래의 문제가 해결되었는지 체크하고, 해결되지 않았다면 최적의 해답을 찾는 과정으로 돌아가 위의 과정을 반복한다. 은 문제를 해결하는 과정에서 매 순간 최적이라고 생각되는 해답을 찾으며, 이를 토대로 최종 문제의 해답에 도달하는 문제 해결 방식이다. 하지만 항상 최적의 결과를 보장하지 못한다는 점을 명심해야 한다. 따라서 아래와 같이 2가지 조건을 모두 성립하지 못한다면 탐욕법을 사용하면 안된다. 앞의 선택이 이후의 선택에 영향을 주지 않는다. 문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 문제 해결 방법으로 구성된다. 은 항상 최적의 결과를 도출하는 것은 아니지만, 어느 정도 최적에 근사한 값…","frontmatter":{"date":"January 04, 2024","title":"알고리즘 준비하기 - 그리디 알고리즘","categories":"알고리즘","author":"재오","emoji":"📚"},"fields":{"slug":"/Greedy/"}},"next":{"id":"3cb14c7c-b7e3-5a44-b6f9-45c4e3ca7b64","html":"<h2 id=\"-다이나믹-프로그래밍-개념\" style=\"position:relative;\"><a href=\"#-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B0%9C%EB%85%90\" aria-label=\" 다이나믹 프로그래밍 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 다이나믹 프로그래밍 개념</h2>\n<p><code class=\"language-text\">DP</code>라고도 불리는 다이나믹 프로그래밍은 명칭과 의미의 상관관계는 없다. 보통 큰 문제를 작은 문제로 나눠서 문제를 해결할 때 이용되는 알고리즘이다.</p>\n<p>사람들에게 익숙한 예시는 피보나치 수열이 있다. 피보나치 수열 역시 <code class=\"language-text\">재귀</code>를 사용하여 수열의 큰 문제를 작은 문제로 나눠서 해결하는 과정이다. 하지만 피보나치 수열과 다이나믹 프로그래밍은 개념적으로 조금 다른 점을 갖는다.</p>\n<h3 id=\"-피보나치-수열의-핵심\" style=\"position:relative;\"><a href=\"#-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98%EC%97%B4%EC%9D%98-%ED%95%B5%EC%8B%AC\" aria-label=\" 피보나치 수열의 핵심 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💎 피보나치 수열의 핵심</h3>\n<ul>\n<li>문제의 크기에 상관 없이 어떤 한 문제의 정답이 일정하다.</li>\n<li>몇번째 피보나치 수를 구하든지에 상관없이 n번째 피보나치수는 항상 동일하다.</li>\n</ul>\n<h3 id=\"-다이나믹-프로그래밍의-핵심\" style=\"position:relative;\"><a href=\"#-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%ED%95%B5%EC%8B%AC\" aria-label=\" 다이나믹 프로그래밍의 핵심 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💎 다이나믹 프로그래밍의 핵심</h3>\n<ul>\n<li>각 작은 문제는 한 번만 풀어야 한다.</li>\n<li>같은 문제는 구할 때마다 정답이 같다.</li>\n<li>정답을 한 번 구했으면, 어딘가에 메모해놓는다.</li>\n<li>메모하는 것을 코드에서는 배열로 구현할 수 있다.</li>\n<li>메모한다고 해서 Memoization이라는 용어를 사용한다.</li>\n</ul>\n<h2 id=\"-다이나믹-프로그래밍-구현\" style=\"position:relative;\"><a href=\"#-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B5%AC%ED%98%84\" aria-label=\" 다이나믹 프로그래밍 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 다이나믹 프로그래밍 구현</h2>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> <span class=\"token function-variable function\">fibo</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">></span> <span class=\"token number\">2</span> <span class=\"token operator\">?</span> <span class=\"token function\">fibo</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fibo</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위는 일반적으로 재귀를 이용하는 피보나치 수의 구현이다. 하지만 결론적으로 피보나치 수열은 이미 계산했던 값을 이용하는 것이라 매우 비효율적이다.</p>\n<p>예를 들어 n의 값으로 5가 들어갔다고 가정해보자. 5번째 피보나치 수를 구하기 위해 4번째, 3번째의 피보나치 수를 구해야 하고 내부 4번째 수를 구하기 위해서는 또 3번째와 2번째의 피보나치 수를 구해야 하고, 3번째 피보나치 수를 구하기 위해 2번째와 1번째의 피보나치 수를 구해야 한다.</p>\n<p>위 단락의 과정은 4번째 피보나치 수를 구한 방식이다. 3번째 피보나치를 구하기위해서 또 3번째 2번째 피보나치 수를 구하고 2번째 1번째 피보나치 수를 구하는, 무한반복의 과정이 이루어진다.</p>\n<p>그래서 아래의 방법을 이용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> fiboArr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> <span class=\"token function-variable function\">fiboWithMemoization</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    fiboArr<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>fiboArr<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    fiboArr<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">fiboWithMemoization</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fiboWithMemoization</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> fiboArr<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위는 DP를 이용한 피보나치 수 구현이다. fiboArr이라는 곳에 내가 계산해둔 피보나치 수를 저장해둔다. 이러한 방식의 차이는 속도면에서 어마어마한 차이를 가져온다. 이를테면 50번째 피보나치 수를 구하는 것은 메모이제이션을 사용하지 않은 단순 재귀에서는 어마어마한 시간이 걸리지만, 메모이제이션을 사용한 피보나치 수 구하기 함수를 이용하면 금방 나온다.</p>\n<h2 id=\"-다이나믹-프로그래밍의-시간복잡도\" style=\"position:relative;\"><a href=\"#-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\" 다이나믹 프로그래밍의 시간복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 다이나믹 프로그래밍의 시간복잡도</h2>\n<p>메모이제이션을 하지 않으면, 대략 O(2n^2) 만큼의 시간복잡도가 걸린다. 하지만 메모이제이션을 하면 대략 O(3n)만큼의 시간에 값을 구하게 된다.</p>\n<h2 id=\"-다이나믹-프로그래밍의-구현-방식\" style=\"position:relative;\"><a href=\"#-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9D\" aria-label=\" 다이나믹 프로그래밍의 구현 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 다이나믹 프로그래밍의 구현 방식</h2>\n<ol>\n<li>\n<p><strong>Top-down</strong>\n큰 문제부터 문제를 쪼개가며 작은 문제로 만들고 다시 합쳐가며 원래 문제를 푸는 방식이다. 위에서 봤던 예제가 <code class=\"language-text\">Top-down</code> 방식이다.</p>\n</li>\n<li>\n<p><strong>Bottom-up</strong>\n작은 문제들을 모아서 큰 문제를 만들어 쌓아 올려가는 방식이다.</p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// bottom-up의 예제</span>\nint d<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nint <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">int n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  d<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  d<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>int i<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span>n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    d<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> d<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> d<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> d<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>설명은 했지만 두 방법 중 하나만 알아도 다이나믹 프로그래밍 문제를 푸는데 큰 지장은 없다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B0%9C%EB%85%90\">🎯 다이나믹 프로그래밍 개념</a></p>\n<ul>\n<li><a href=\"#-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98%EC%97%B4%EC%9D%98-%ED%95%B5%EC%8B%AC\">💎 피보나치 수열의 핵심</a></li>\n<li><a href=\"#-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%ED%95%B5%EC%8B%AC\">💎 다이나믹 프로그래밍의 핵심</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B5%AC%ED%98%84\">🎯 다이나믹 프로그래밍 구현</a></p>\n</li>\n<li>\n<p><a href=\"#-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84\">🎯 다이나믹 프로그래밍의 시간복잡도</a></p>\n</li>\n<li>\n<p><a href=\"#-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9D\">🎯 다이나믹 프로그래밍의 구현 방식</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"January 01, 2024","title":"알고리즘 준비하기 - 다이나믹 프로그래밍","categories":"알고리즘","author":"재오","emoji":"📚"},"fields":{"slug":"/DP/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://www.jaeochoiii.com","comments":{"utterances":{"repo":"jaeochoii/jaeochoii.github.io"}}}}},"pageContext":{"slug":"/Greedy/","nextSlug":"/DP/","prevSlug":""}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}