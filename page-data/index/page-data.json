{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"90a4f21e-90ba-515c-861b-22f05eb64a8a","excerpt":"🎯 트리 트리는 계층적인 자료를 표현하는 데 사용되는 자료구조이다.  Node\ntree의 각 요소를 노드라고 한다. B를 A의 자식 노드, A를 B의 부모 노드라고 한다. 각 Node는 자신의 데이터를 가지고 있으며, 자식 노드의 주소를 가지고 있을 수도 있다. Root Node\nA와 같이 부모 노드가 없고 최상단에 위치한 Node를 루트 노드라고 한다. Leaf Node\nH, I, E, J, G처럼 자식 노드가 없는 노드를 Leaf Node라고 한다. Size\n모든 Node의 갯수를 크기라고 한다. Depth\nRoot Node로부터의 거리를 깊이라고 한다. 🎯 이진 트리 자식 노드의 갯수가 최대 2개로 한정된 tree를 말한다.  최대 자식 노드 갯수가 2개인 것 뿐이므로 위 그림에서 G노드가 없어도 이진 트리이다. 🎯 이진 탐색 트리 이진 탐색이 동작할 수 있도록 고안된 자료구조의 일종이다. 왼쪽 자식 노드가 부모 노드보다 작고 오른쪽 자식 노드가 부모 노드보다 큰 이진 트리를…","frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - 이진 트리와 이진 순회","date":"February 06, 2024"},"fields":{"slug":"/BinaryTree/"}}},{"node":{"id":"ac5f637b-bdf2-5cb7-8b9b-65f6828cf042","excerpt":"🎯 다익스트라 다익스트라 알고리즘은 하나의 시작 지점으로부터 모든 다른 지점까지의 최단 경로를 찾는 알고리즘이다. 다익스트라 알고리즘은 기본적으로 그리디 알고리즘으로 분류된다. ‘매번 경로의 길이가 짧은 노드를 선택하는 과정’을 반복하기 때문이다. 🎯 다익스트라 알고리즘의 과정 시작 정점을 설정하고, 시작 정점의 거리 값을 0으로 설정한다. 시작 정점을 제외한 모든 정점의 거리 값을 무핟내로 설정한다. 현재까지 방문하지 않은 정점 중에서 출발점에서 가장 가까운 정점을 선택한다. 해당 정점의 이웃 정점에 대해서, 출발점에서 해당 이웃 정점까지의 거리를 계산한다. 계산된 거리가 해당 이웃 정점의 현재 거리 값보다 작다면, 해당 이웃 정점의 거리 값을 갱신한다. 모든 정점을 방문할 때까지 위 과정을 반복한다. 🎯 다익스트라 알고리즘 구현 다익스트라 알고리즘은 을 사용하여 구현한다. 우선순위 큐를 사용하면 구현이 더 빠르고 간단해진다. 큐에서 뽑힌 정점은 해당 정점에서부터 가장 짧은 거리…","frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - 다익스트라","date":"January 26, 2024"},"fields":{"slug":"/Dijkstra/"}}},{"node":{"id":"245e12de-6d29-5663-9356-7481970a3ff1","excerpt":"🎯 우선순위 큐 우선순위 큐를 구현할 때 내부적으로 최소 힙 또는 최대 힙을 이용한다. 최소 힙을 이용하는 경우 ‘값이 가장 낮은 데이터가 먼저 삭제’되며, 최대 힙을 이용하는 경우 ‘값이 큰 데이터가 먼저 삭제’된다. 이때 힙은 삽입과 삭제에 O(NlogN)의 시간 복잡도를 가진다. 🎯 힙의 특징 힙의 부모와 자식 간에 다음과 같은 관계가 성립한다. 왼쪽 자식의 index : 부모의 index * 2 + 1 오른쪽 자식의 index : (부모의 index * 2) + 2 부모의 index : Math.floor((자식의 index - 1) / 2) 🎯 삽입 연산 (bubbleUp) 의 삽입 연산은 다음과 같은 단계로 이루어진다. Heap의 마지막 위치에 요소를 추가한다. 새로운 요소를 추가한 위치에서부터, 부모 노드와 새로 추가된 노드의 값을 비교한다. 만약 새로 추가된 노드의 값이 부모 노드의 값보다 작다면, 부모 노드와 새로 추가된 노드의 위치를 교환한다. 이전 단계에서 교환…","frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - MinHeap 구현하기","date":"January 26, 2024"},"fields":{"slug":"/MinHeap/"}}},{"node":{"id":"dd6a403b-d7db-59b2-9f8e-e68d96028f8a","excerpt":"🎯 LCS 알고리즘  알고리즘은 최장 공통 부분수열(Longest Common Subsequence), 혹은 최장 공통 문자열(Longest Common Substring)을 의미한다. 문자열 하나하나 모두 비교를 하다보면 시간복잡도가 최대 O(n^4)이 되기때문에 DP를 이용하는 것을 추천한다. 🎯 최장 공통 문자열 구하기 최장 공통 문자열을 구하는 과정은 상당히 쉽다. 최장 공통 부분수열을 구하기 이전에 다루고 가면 도움이 될 것 같아서 정리를 해보고자 한다. 문자열A와 문자열B를 한글자씩 비교한다. 두 문자가 다르다면 LCS[i][j]에 0을 표시한다. 두 문자가 같다면 LCS[i-1][j-1] 값을 찾아서 해당 값보다 +1한 값을 LCS[i][j]에 넣는다. 위 과정을 이중배열 끝까지 반복한다. 위 과정이 공통 문자열을 구하는 것에서 성립되는 이유는 공통 문자열은 문자가 모두 연속되어야 하는 특성때문이다. 현재 두 문자가 같을 때 두 문자의 앞글자까지가 공통 문자열이라면 계…","frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - DP를 활용한 LCS","date":"January 25, 2024"},"fields":{"slug":"/LCS/"}}},{"node":{"id":"d096d1b9-f9c8-54ae-8a22-c02aa170ba18","excerpt":"우선 DP 알고리즘의 기본 개념은 알고리즘 준비하기 - 다이나믹 프로그래밍에 잘 정리해두었으니 참고하면 좋을 것 같다. 👉 문제 확인하기 : BOJ - 평범한 배낭 🎯 배낭문제 다이나믹 프로그래밍 (DP) 문제 중 대표적인 유형이 바로 0/1 배낭 문제이다. 물건의 개수 N이 주어지고, 배낭이 최대로 버틸 수 있는 무게 K가 주어진다. 각 물건의 무게와 가치가 주어질 때 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 구하는 문제가 바로 배낭 문제이다. 그 중에서 0/1인 이유는 물건을 쪼개서 넣을 수는 없고 물건을 넣거나, 혹은 넣지 않거나 둘 중 하나의 선택만 할 수 있기 때문이다.  문제를 인용해서 설명을 해보도록 하자. 물건의 개수(N)는 4개, 배낭의 무게(K)는 7이다.  물건1 물건2 물건3 물건4 무게 6 4 3 5 가치 13 8 6 12 물건의 개수가 4개라서 브루트포스 알고리즘으로 구하더라도 짧은 시간내에 구할 수는 있으나 물건의 개수가 조금만 더 늘어난다면 따져보…","frontmatter":{"categories":"알고리즘","title":"알고리즘 연습하기 - DP를 활용한 배낭문제","date":"January 22, 2024"},"fields":{"slug":"/Bag/"}}},{"node":{"id":"3c3ed5f6-6990-51c8-93e1-7bb2fc711d4d","excerpt":"👉 참고할 문제 : BOJ - IOIO 🎯 KMP 알고리즘 백준 브론즈 - 실버 문제를 접할 때 정말 많이 나오는 유형이 문자열 문제이다. 문제의 길이도 짧고, 직관적으로 이해가 가는 문제였기 때문에 어렵게 느껴지지도 않는다. 하지만 메모리 초과나 시간 초과가 무조건 한번씩은 발생한다. 특히 Node.js로 문제를 해결하고자 할 때 문자열을 다루는 내장함수 , , 가 존재하기 때문에 시간복잡도가 문자열 길이의 곱에 비례하여 O(NM)이 된다. 시간복잡도가 O(NM)인 것을 O(N+M)으로 줄일 수 있는 알고리즘이 바로 이다. 이 KMP 알고리즘의 핵심 키워드는 패턴을 정의해서 했던 비교를 또 하지 않는다. 이다. 💎 패턴을 관리하는 Failure 배열 만들기 우리에게는 검색의 대상이되는 문자열(origin)과, 찾아야하는 패턴의 문자(keyword), 추가적으로 KMP를 위해 추가되는 개념인 이 존재한다. 예를 들어 origin은 전체 길이가 16인 ‘aabcacabcabcacab…","frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - KMP","date":"January 21, 2024"},"fields":{"slug":"/KMP/"}}},{"node":{"id":"ba912085-9e11-571e-aa3e-2d58e12b380f","excerpt":"우선 BFS 알고리즘의 기본 개념은 알고리즘 준비하기 -BFS 에 잘 정리해두었으니 참고하면 좋을 것 같다. 👉 문제 확인하기 : BOJ - 벽 부수고 이동하기 🎯 문제  🎯 접근 방법 우선 이번 포스트를 작성하게 된 계기는 문제를 풀면서 끝없는 메모리 초과 문제때문이었다. 다른 사람들의 풀이를 보면 3차원 배열을 사용하여 접근하였지만 2차원 배열만으로도 충분히 문제가 풀렸기에 내 풀이에 고집이 있었다. 💎 1차 시도 (❌) 다른 사람들의 게시판 글 후기를 보면 큐(Queue)를 구현하는 것에 있어서 시간초과가 많이 발생했다고 한다. 다양한 BFS 문제를 겪어본 결과 Node.js에서는 무조건 Queue를 직접 구현해서 사용해야 한다. 즉 shift를 사용하는 순간 어마무시한 배열을 한칸식 옮겨줘야 하기 때문에 사용을 지양한다. 여기까지는 별 문제가 없었다. 벽을 1번은 깰 수 있다고 하는데 그렇다면 백트래킹을 이용해서 배열에 있는 모든 1을 0으로 한번씩 바꿔서 BFS를 돌리면 …","frontmatter":{"categories":"알고리즘","title":"알고리즘 연습하기 - BFS의 3차원적 접근","date":"January 19, 2024"},"fields":{"slug":"/Practice2/"}}},{"node":{"id":"34cd6673-fc6d-5ed6-b04d-f5803b944bf8","excerpt":"👉 문제 확인하기 : BOJ 15685 치킨배달 🎯 문제  🎯 접근 방법 이 문제는 백트래킹 알고리즘을 이용하는 구현에 조금 더 가까운 문제이다. 문제를 한번 쭉 읽고 어떤 데이터 값이 필요하고 어떻게 가공하면 원하는 답에 접근할 수 있는지에 대해 고민한다면 빠른 시간 내에 해결이 가능하다. 집(1)의 위치를 배열로 저장해야 한다. -> 최종적으로는 집에서부터 치킨 집까지의 거리를 구해야 하기 때문이다. 치킨집(2)의 위치를 배열로 저장해야 한다. -> 주어진 입력값에는 치킨집이 여러개 존재한다. 하지만 M개 만큼의 치킨집만 거리 계산에 이용될 수 있기 때문이다. 위에서 M개 만큼의 치킨집만 거리 계산에 이용이 된다고 했는데 그럼 M개의 치킨집을 가정하여 집에서부터의 M개의 치킨집까지의 최소 거리를 구해야 한다. -> 중복되지 않는 M개의 치킨집의 좌표를 구해야 하기 때문에 백트래킹 알고리즘을 사용한다. M개의 치킨집이 정해졌다면 해당 치킨집에서부터 집까지의 거리를 구해 더해준다.…","frontmatter":{"categories":"알고리즘","title":"알고리즘 연습하기 - 백트래킹, 구현","date":"January 17, 2024"},"fields":{"slug":"/Practice/"}}},{"node":{"id":"938e4f55-4183-53c3-9cff-45e4b1d4ae95","excerpt":"🎯 백트래킹 은 해를 찾아가는 도중, 지금의 경로가 정답이 될 것 같지 않으면 그 경로를 더이상 가지 않고 되돌아가는 방법이다. 백트래킹은  알고리즘을 사용하는데 기존 DFS는 엄청나게 큰 경우의 수라면 모든 케이스를 다 순회해야 하기 때문에 비효율적인 방법을 대체하고자 등장한 알고리즘이다. 즉, 코딩에서는 반복문의 횟수까지 줄일 수 있는 아주 효율적인 알고리즘이다. 이를 흔한 용어로 가지 치기리고 하는데, 불필요한 부분을 쳐내고 최대한 올바른 쪽으로 간다는 의미로 불린다. 일반적으로, 불필요한 경로를 조기에 차단할 수 있게 되어 경우의 수가 줄어들지만, 만약 N!의 경우의 수를 가진 문제에서 최악의 경우에는 여전히 지수함수 시간을 필요로 하므로 처리가 불가능 할 수도 있다. 즉 가지 치기를 얼마나 잘하느냐에 따라 효율성이 결정된다. 정리하자면, 백트래킹은 모든 가능한 경우의 수 중에서 특정한 조건을 만족하는 경우만 살펴보는 것이다. 즉 답이 될 만한지 판단하고 그렇지 않으면 그 …","frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - 백트래킹","date":"January 16, 2024"},"fields":{"slug":"/BackTracking/"}}},{"node":{"id":"b6e37b2a-fba7-50b6-9135-e888bb3045bb","excerpt":"🎯 CCW  알고리즘은 3개의 점 A, B, C가 있을 때 이 점 3개를 이은 직선의 방향을 알고자 할 때 유용한 방법이다. 경우의 수는 총 시계방향, 반시계방향, 직선 3가지가 존재한다. 기하와 벡터에서 을 사용해서 구한다고 하는데 본인은 문과 수학만 배웠기에 외적에 대해 많은 문서를 읽어봐도 이해가 잘 가지 않았다. 따라서 직선의 방정식을 이용해서 이에 대해 설명하고자 한다. 💎 직선의 방정식 구하기 좌표 A(X1, X2)와 B(X2, Y2)의 직선의 방정식을 구해보자. 💎 C 대입하기 X2 - X1 값이 양수인 경우 (직선의 방향이 오른쪽인 경우) X2 - X1 값이 음수인 경우 (직선의 방향이 왼쪽인 경우) 💎 통일 시켜서 하나의 식으로 정리하기 X2 - X1 값의 양수 여부에 따라 부등호의 결과가 반대이므로 X2 - X1을 양쪽에 곱해서 부등호를 통일시킨다. 이후 X2 - X1이 양수일 때에는 곱해도 부등호가 유지되고, 음수일 경우는 곱하면 부등호가 반대로 뒤집히는 것을 …","frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - CCW","date":"January 13, 2024"},"fields":{"slug":"/CCW/"}}},{"node":{"id":"cc99fd35-e99b-5ebc-b623-2dbf7d06b387","excerpt":"🎯 플로이드-워셜 알고리즘 모든 최단 경로를 구하는 알고리즘이다. 이후에 정리할 은 하나의 정점에서 다른 모든 정점까지의 최단 거리를 구하는 알고리즘이었다면, 플로이드-워셜 알고리즘은 한 번 실행하여 모든 노드 간 최단 경로를 구할 수 있다. 💎 플로이드-워셜 알고리즘의 과정 모든 노드 간의 최단거리를 구해야 하는 것이 의 목표이다. 따라서 2차원 인접 행렬로 구한다. 알고리즘은 여러 라운드로 구성이 되는데 라운드마다 각 경로에서 중간 노드로 사용할 수 있는 노드를 선택하고, 더 짧은 길이를 선택하여 줄이는 과정을 반복한다. [STEP 0] 그래프의 노드와 간선에 따라 최단 거리 테이블을 갱신한다.\n [STEP 1] 1번 노드를 거쳐 가는 경우를 고려하여 테이블을 갱신한다.\n [STEP 2] 2번 노드를 거쳐 가는 경우를 고려하여 테이블을 갱신한다.\n [STEP 3] 3번, 4번 노드를 거쳐 가는 경우를 고려하여 테이블을 갱신한다.\n  🎯 플로이드-워셜 알고리즘 코드 구현 (JS)…","frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - 플로이드 워셜","date":"January 09, 2024"},"fields":{"slug":"/Wallshall/"}}},{"node":{"id":"a7c176b4-e855-5613-b211-aedeb710b935","excerpt":"🎯 BFS 는 너비 우선 탐색이라고 하며 시작 노드로부터 가까운 노드를 먼저 방문하고 멀리 떨어져있는 노드를 나중에 방문하는 탐색 방법이다. DFS는 최대한 멀리 있는 노드를 우선으로 탐색하는데, BFS는 그 반대다. 보통 BFS는 선입선출 방식인 큐 자료구조를 이용하는 것이 일반적이다. 다른 언어의 경우는 보통 내장 라이브러리에 큐를 제공하고 있지만 자바스크립트는 큐와 관련된 객체가 내장되어 있지 않다. 따라서 BFS를 이용하기 위해서는 큐 자료구조를 따로 구현해줘야 한다. 💎 BFS의 동작 방식 우선 탐색 시작 노드를 큐에 삽입하고 방문 처리한다. 다음으로 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리한다. 이 과정을 더 이상 수행할 수 없을 때까지 반복한다. 🎯 BFS 구현 (JS) 큐(Queue) 구현 코드 🎯 BFS의 시간 복잡도 BFS는 DFS와 마찬가지로 그래프가 인접 리스트로 표현되어 있으면 전체 수행시간이 O(…","frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - BFS","date":"January 07, 2024"},"fields":{"slug":"/BFS/"}}},{"node":{"id":"93234af2-bc05-5c48-9204-1bea11095217","excerpt":"🎯 그래프(Graph) 그래프는 객체 사이의 연결 관계를 표현할 수 있는 자료 구조로 실제 세계의 현상이나 사물을 정점(V)과 간선(E)으로 표현한 것이다. 한마디로 그래프는 정점과 간선들의 유한집합이라고 통칭할 수 있다. 💎 그래프의 표현 방법 프로그래밍에서 그래프는 크게 2가지 방식으로 표현할 수 있는데 과 이다. 은 2차원 배열로 각 노드의 연결 관계를 표현하는 방식이다. 연결이 되어 있지 않은 노트끼리 무한의 비용이라고 작성한다. 노드에 대해 가중치가 있을 때는 가중치를 입력해주고 가중치가 없는 경우에는 1과 0으로 표기한다. 인접 행렬 방식을 사용하면 노드의 연결 관계를 담은 배열이 중앙 대각선을 기준으로 대칭을 이루게 된다. 반면 는 리스트로 그래프의 연결 관계를 표현하는 방식으로 모든 노드에 연결 정보를 차례대로 연결하여 저장한다. 노드에 대해 가중치가 있을 때는 아래와 같이 가중치를 입력해주고 가중치가 없는 경우에는 2차원 배열로 표기한다. 💎 인접 행렬과 인접 리스…","frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - 그래프와 DFS","date":"January 06, 2024"},"fields":{"slug":"/DFS/"}}},{"node":{"id":"016a6a1c-1d34-53ec-9b71-0c2ea3323aae","excerpt":"🎯 그리디 알고리즘 그리디 알고리즘, 즉 은 말 그대로 선택의 순간마다 눈앞에 보이는 최적의 상황만을 쫓아서 최종적인 해답에 도달하는 방법이다. 을 이용하여 문제를 해결하는 순서는 아래와 같다. 현재 상태에서의 최적의 해답을 선택한다. 선택된 해가 문제의 조건을 만족하는지 검사한다. 원래의 문제가 해결되었는지 체크하고, 해결되지 않았다면 최적의 해답을 찾는 과정으로 돌아가 위의 과정을 반복한다. 은 문제를 해결하는 과정에서 매 순간 최적이라고 생각되는 해답을 찾으며, 이를 토대로 최종 문제의 해답에 도달하는 문제 해결 방식이다. 하지만 항상 최적의 결과를 보장하지 못한다는 점을 명심해야 한다. 따라서 아래와 같이 2가지 조건을 모두 성립하지 못한다면 탐욕법을 사용하면 안된다. 앞의 선택이 이후의 선택에 영향을 주지 않는다. 문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 문제 해결 방법으로 구성된다. 은 항상 최적의 결과를 도출하는 것은 아니지만, 어느 정도 최적에 근사한 값…","frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - 그리디 알고리즘","date":"January 04, 2024"},"fields":{"slug":"/Greedy/"}}},{"node":{"id":"3cb14c7c-b7e3-5a44-b6f9-45c4e3ca7b64","excerpt":"🎯 다이나믹 프로그래밍 개념 라고도 불리는 다이나믹 프로그래밍은 명칭과 의미의 상관관계는 없다. 보통 큰 문제를 작은 문제로 나눠서 문제를 해결할 때 이용되는 알고리즘이다. 사람들에게 익숙한 예시는 피보나치 수열이 있다. 피보나치 수열 역시 를 사용하여 수열의 큰 문제를 작은 문제로 나눠서 해결하는 과정이다. 하지만 피보나치 수열과 다이나믹 프로그래밍은 개념적으로 조금 다른 점을 갖는다. 💎 피보나치 수열의 핵심 문제의 크기에 상관 없이 어떤 한 문제의 정답이 일정하다. 몇번째 피보나치 수를 구하든지에 상관없이 n번째 피보나치수는 항상 동일하다. 💎 다이나믹 프로그래밍의 핵심 각 작은 문제는 한 번만 풀어야 한다. 같은 문제는 구할 때마다 정답이 같다. 정답을 한 번 구했으면, 어딘가에 메모해놓는다. 메모하는 것을 코드에서는 배열로 구현할 수 있다. 메모한다고 해서 Memoization이라는 용어를 사용한다. 🎯 다이나믹 프로그래밍 구현 위는 일반적으로 재귀를 이용하는 피보나치 수…","frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - 다이나믹 프로그래밍","date":"January 01, 2024"},"fields":{"slug":"/DP/"}}},{"node":{"id":"95c11caa-a9f2-574d-b232-ec45b604d447","excerpt":"🎯 맵 은 키가 있는 데이터를 저장한다는 점에서 객체와 매우 유사하다. 다만, 객체와 다른 점은 키에 다양한 자료형을 허용한다는 점에서 차이가 있다. 맵에는 다음과 같은 주요 메서드와 프로퍼티가 있다. new Map() : 맵을 생성한다. map.set(key, value) : key를 이용해 value를 저장한다. map.get(key) : key에 해당하는 값을 반환한다. key가 존재하지 않으면 undefined를 반환한다. map.has(key) : key가 존재하면 true, 존재하지 않으면 false를 반환한다. map.delete(key) : key에 해당하는 값을 삭제한다. map.clear() : 맵 안의 모든 요소를 제거한다. map.size() : 요소의 개수를 반환한다. 주의해야할 점은 map[key]는 Map을 사용하는 올바른 방법이 아니다. 이 방법은 map을 일반 객체처럼 취급하게 된다. 따라서 여러 제약이 생기게 된다. map을 사용할 땐 map 전용 …","frontmatter":{"categories":"자바스크립트","title":"자바스크립트 정리하기 - Map과 Set","date":"December 31, 2023"},"fields":{"slug":"/MapSet/"}}},{"node":{"id":"53b0dd88-2015-5f8d-8553-b5377120dcf2","excerpt":"🎯 우선순위 큐 우선순위 큐는 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조의 일부이며 데이터를 우선순위에 따라 처리하고 싶을 때 사용한다. 🎯 우선순위 큐의 구현 방법 크게 2가지로 분류할 수 있다. 로 구현하는 방법과 으로 구현하는 방법. 우선 배열로 구현하는 것은 구현 자체가 간단하다는 장점이 있지만 데이터를 삭제하거나 삽입해야하는 경우 모든 인덱스를 탐색해야 하는 과정이 있기 때문에 시간복잡도가 **O(N)**이 되므로 상대적으로 부족한 성능을 보여준다. 하지만 힙으로 구현하는 것은 구현 자체에서 난이도가 높지만 시간복잡도가 **O(logN)**이기 때문에 좋은 성능을 보여준다. 🎯 힙의 특징 그렇다면 힙의 특징은 무엇일까?  힙은 완전 이진 트리 자료구조이다. 완전 이진 트리란 마지막 레벨을 제외하고 모든 레벨이 모두 채워져있으며, 마지막 레벨의 모든 노드는 가능한 왼쪽에 위치한다. 즉, 루트 노드로부터 시작하여 왼쪽에서 오른쪽 자식 노드 순서대로 데이터가 순…","frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - 우선순위 큐","date":"December 21, 2023"},"fields":{"slug":"/PriorityQueue/"}}},{"node":{"id":"aa5ca993-92ca-5fb5-9cd4-e91bf8dee082","excerpt":"자바 언어를 사용하는 친구들이랑 개발 이야기를 하다보면 정말 자주 등장하는 주제가 이었다. 자바스크립트에 이 없다는 것을 친구들은 믿지 않았다. 그게 없으면 대체 변하지 않는 값은 어떻게 저장을 하냐고…저렇게 편한 것이 없으면 개발을 어떻게 하냐고… 진짜 더욱 궁금했다. 대충 어떤 용도로 Enum을 사용하는구나 정도로만 이해하고 넘어갔다. 어짜피 자바스크립트에는 없으니까… 하지만 타입스크립트에서는 을 사용한다는 것을 듣고 이 흥분된 기분을 감출 수 없어 바로 블로깅하러 왔다. 나도 드디어 을 쓸 수 있겠구나…! 이번 기회에 Enum에 대해 한번 정리하고 넘어가고자 한다. 🎯 Enum 은 여러 값들에 미리 이름을 정의하여 열거해두고 사용하는 타입이다. 객체와 비슷하게 원하는 값을 고정시키고 사용할 때 주로 사용한다. 하지만 의문이다. 굳이 왜 을 사용하는 것일까? 자바스크립트의 객체는 key와 value 값이 변경될 수 있다는 점이 큰 단점이다. 하지만 enum은 불변한 상수의 열거…","frontmatter":{"categories":"타입스크립트","title":"Enum 한 번 써보자","date":"December 21, 2023"},"fields":{"slug":"/TS2/"}}},{"node":{"id":"0bcbd73f-3ba9-5098-a5d0-43357534bec3","excerpt":"🎯 TS는 타입 애너테이션 방식 타입스크립트는  방식을 사용하는데 이는 변수나 상수 혹은 함수의 인자와 반환 값에 타입을 명시적으로 선언하여 어떤 타입 값이 저장될 것인지를 컴파일러에 직접 알려주는 문법이다. 사실 위의 예시에서  선언부를 제거해도 코드는 정상적으로 동작한다. 하지만 타입을 제거하면 타입스크립트 타입 시스템이 타입 추론을 하는 과정에서 어려움을 겪을 것이다. 🎯 TS는 구조적 타이핑이다 다른 언어와는 다르게 타입스크립트에서 타입을 구분하는 방식은 조금 다르다. 타입스크립트는 구조로 타입을 구분하는데 이것을 이라고 한다. 이를 예시와 함께 살펴보자. 몹시 당황스러운 코드이다. 분명 greet이라는 함수의 매개변수로 들어갈 수 있는 값은 Pet 타입으로 제한되어 있다. 그러나 타입을 따로 명시하지 않은 cat 객체를 greet 함수의 인자로 전달해도 코드는 정상적으로 실행된다. 이유는 cat 객체는 Pet 인터페이스가 가지고 있는 name 속성을 가지고 있어 pet.n…","frontmatter":{"categories":"타입스크립트","title":"타입스크립트의 타입 시스템","date":"December 20, 2023"},"fields":{"slug":"/TS1/"}}},{"node":{"id":"712c5bd0-bbf8-5bc3-9fcd-aa8585716a72","excerpt":"💡forEach 와 map의 정확한 차이 파악 기억해야 할 점은 map은 새로운 배열을 반환한다는 점이다. 반환 값은 단순히 버려지기 때문에 에서 반환하지 않는다. 반면 은 새로운 배열을 반환한다. 만약 함수형 프로그래밍을 선호한다면 을 사용하는 것이 더 바람직하다.  를 사용한다면 기존 Array에 영향을 주는 반면에 은 완전히 새로운 Array를 반환하기 때문에 원래의 배열을 건들지 않는다. 또한 데이터를 변경할 때 다른 메서드를 연결하는 것도 이 훨씬 수월하다. 💡 slice와 splice의 차이 파악  함수는 인자로 시작 인덱스와 종료 인덱스를 받는다. **중요한 점은 종료 인덱스는 반환에 포함시키지 않고, 원본 배열은 절대 변경되지 않는다. **  함수는 와 다르게 원본 배열을 변경시킨다. 또한 시작 인덱스부터 몇개를 삭제할 것인지, 즉 시작 인덱스와 개수를 인자로 받는다. 이 부분은 예시와 함께 살펴보자. 또한 특정 배열의 값을 제거하고 그 자리에 다른 값을 채워 넣을 …","frontmatter":{"categories":"알고리즘","title":"기억해야할 코딩테스트 빈출 문법","date":"December 19, 2023"},"fields":{"slug":"/Tips/"}}},{"node":{"id":"5ca529d9-3564-52cc-80c3-96d53cfa80e7","excerpt":"🎯 에라토스테네스의 체 백준, 프로그래머스 문제를 풀다보면 정말 많이 등장하는 유형이 바로  이다.  는 바로 소수를 찾는 방법 중 하나이다.  알고리즘의 원리는 다음과 같다. 숫자 2를 시작으로 2를 빈 곳에 적어두고, 정해진 숫자의 범위의 마지막 숫자까지 모든 2의 배수를 제거한다. 다음 숫자인 3을 빈 곳에 적어두고, 정해진 숫자의 범위의 마지막 숫자까지 모든 3의 배수를 제거한다. 4는 제거했기 때문에 다음 숫자인 5로 넘어간다. 정해진 숫자의 범위의 마지막 숫자까지 모든 5의 배수를 제거한다. 위 과정을 마지막 숫자까지 반복한다. 빈 곳에 적어둔 숫자가 소수에 해당한다. 🎯 메모리를 효율적으로 관리하는 방법 위에서 설명하는 과정을 조금 더 분석해보면 정해진 숫자의 범위의 마지막 숫자까지의 수의 제곱근까지만 반복문을 진행해 배수를 제거하면 된다. 예를 들어 120까지의 숫자를 순회하면서 소수를 찾는 과정이라면 11^2 > 120인 11까지만 배수를 제거하고, 그 이후의 모든…","frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - 에라토스테네스의 체","date":"December 19, 2023"},"fields":{"slug":"/EratosTenes/"}}},{"node":{"id":"91e26d8e-2e0c-5763-9a55-88d7efd335cb","excerpt":"🎯 스택(Stack) 스택은 쉽게 생각하면 박스에 물건을 차곡차곡 정리하는 형태이다. 먼저 들어간 것이 밑에 위치하기 때문에 나중에 나오게 되고, 나중에 들어간 것이 맨 위에 위치하기 때문에 먼저 나오는 형태의 자료구조이다. 때문에 스택의 모든 연산은 스택의 최상단에서 일어난다. LIFO(Last In First Out) 스택은 서로 관계가 있는 여러 작업을 연달아 수행하면서 이전의 작업 내용을 저장해 둘 필요가 있을 때 사용된다. 스택 구현 코드 (JS) 스택 시간복잡도 push: O(1) pop: O(1) 🎯 큐(Queue) 큐는 대기 줄을 생각하면 이해가 쉽다. 대기 줄에서는 먼저 들어온 사람이 먼저 나가듯 큐에서도 먼저 들어온 데이터가 먼저 나가고 나중에 들어온 데이터가 나중에 나가는 형태의 자료구조이다. 데이터의 삽입과 삭제가 큐의 양끝에서 각각 일어나므로 큐의 앞과 뒤를 명확하게 구분지을 필요가 있다. FIFO(First In First Out) 큐는 순서대로 처리해야 …","frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - Stack Queue Deque","date":"December 16, 2023"},"fields":{"slug":"/StackQueueDeque/"}}},{"node":{"id":"6aabacec-58ca-5d36-8354-04c7cdb477cc","excerpt":"길고 길었던 우아한테크코스의 여정이 끝이 났다. 비록 합격이라는 좋은 결과를 얻지는 못했지만, 돌이켜보면 개발자로서 많은 것을 얻었던 시간이었다. 그중에서 객체 지향과 관련해서는 4주간의 프리코스 내내 스스로를 괴롭혔다. 1주차, 2주차, 그리고 4주차까지 미션을 진행하면서 내 코드에 대해 매번 만족했었다. “그래, 이정도면 됐다! 이 정도면 객체도 잘 분리했고, 요구사항도 잘 지켜졌고, 이보다 더 나아질 수는 없다!” 그리고 코드 리뷰를 받거나 공통 피드백을 확인하면 내가 제출했던 코드가 얼마나 잘못 작성되었는지 알 수 있었다. 해당 미션에서 무언가를 잘 지켜내면, 또 다음 미션에서 잘못된 무언가가 나오고, 이게 4주간 반복되었다. 객체 지향적인 코드를 작성하는 것은 정해진 것 없이 끝이 없는 작업이라는 것을 깨달았다. 그 말은 좋은 코드에 정해진 답도 없다를 의미하는 것 같았다. 하지만 완벽은 아니더라도, 더 나은 코드는 작성할 수 있지 않을까…? 프리코스 1주차, 그리고 코드…","frontmatter":{"categories":"회고","title":"나의 코드는 얼마나 객체 지향적이었는가?","date":"December 13, 2023"},"fields":{"slug":"/AfterPrecourse/"}}}]},"site":{"siteMetadata":{"language":"ko","author":{"name":["재오","최재오"],"bio":{"role":"개발자","description":["JavaScript","TypeScript","React"],"thumbnail":"bear.PNG"},"social":{"github":"https://github.com/jaeochoii","linkedIn":"https://www.linkedin.com/in/%EC%9E%AC%EC%98%A4-%EC%B5%9C-187625299/","email":"jaeochoiii0716@naver.com"}}}}},"pageContext":{}},"staticQueryHashes":["1073350324","1956554647","2938748437","3350743975"]}