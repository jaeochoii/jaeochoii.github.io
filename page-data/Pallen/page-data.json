{"componentChunkName":"component---src-templates-blog-template-js","path":"/Pallen/","result":{"data":{"cur":{"id":"d9da81e4-2e95-50f2-8edf-75c280ea5df4","html":"<h2 id=\"-팰린드롬\" style=\"position:relative;\"><a href=\"#-%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC\" aria-label=\" 팰린드롬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 팰린드롬</h2>\n<p>상당히 어려운 부분이었다. 우선적으로 이야기하자면 <code class=\"language-text\">팰린드롬</code>은 어떤 문자가 뒤집어도 대칭이 유지되는 것을 의미한다. 예를들어 ‘A’, ‘AA’, ‘ABCBA’가 팰린드롬에 해당된다.</p>\n<p>👉 관련 문제 확인하기 : <a href=\"https://www.acmicpc.net/problem/10942\">BOJ - 팰린드롬?</a></p>\n<p>이것을 구현하기 위해서는 2차원 DP배열을 활용해야 한다. 순서는 상관이 없지만 i 인덱스를 문자열의 시작점, j 인덱스를 문자열의 종점이라고 둔다면 DP[i][j]는 문자열의 i번째부터 j번째까지의 팰린드롬 유무를 확인하는 작업이라고 생각하면 편하다.</p>\n<p>여기서 주의해야할 점은 문자의 길이가 1일 때, 문자의 길이가 2일 때, 그리고 이상일 때, 총 3가지로 분류해서 DP배열에 값을 넣는 작업을 해주면 된다.</p>\n<ul>\n<li>문자의 길이가 1일 때: 팰린드롬이 무조건 가능하다.</li>\n<li>문자의 길이가 2일 때: 두글자 모두 동일한 경우에만 팰린드롬이 가능하다.</li>\n<li>문자의 길이가 3일 때: 첫글자, 마지막 글자가 같은 경우에, 그리고 그 두 글자를 제외한 안에 있는 문자가 팰린드롬이 가능한 경우에 가능하다.</li>\n</ul>\n<p>위 작업의 코드는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> stringArr <span class=\"token operator\">=</span> input<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> board <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">length</span><span class=\"token operator\">:</span> <span class=\"token constant\">N</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">Array</span><span class=\"token punctuation\">(</span><span class=\"token constant\">N</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 문자의 길이가 1일 때</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token constant\">N</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  board<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 문자의 길이가 2일 때</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token constant\">N</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>stringArr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> stringArr<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    board<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 문자의 길이가 3이상일 때</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token constant\">N</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> <span class=\"token constant\">N</span> <span class=\"token operator\">-</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> k <span class=\"token operator\">=</span> j <span class=\"token operator\">+</span> i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>stringArr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> stringArr<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> board<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"-팰린드롬의-분할\" style=\"position:relative;\"><a href=\"#-%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC%EC%9D%98-%EB%B6%84%ED%95%A0\" aria-label=\" 팰린드롬의 분할 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 팰린드롬의 분할</h2>\n<p>👉 문제 확인하기: <a href=\"https://www.acmicpc.net/problem/1509\">BOJ - 팰린드롬 분할</a></p>\n<p>이론적인 위 내용을 이해했다면 이 문제를 해결할 수 있다. 이 문제… 사실 정말 너무 어려웠다. 팰린드롬을 제작하는 것까지는 위 코드를 그대로 가져와서 사용해도 되었으나 문제는 그 다음부터였다. 팰린드롬으로 여러개가 분할될 수 있는데 그 중에서 팰린드롬으로 분할되었을 때의 총 개수가 가장 작은 것으로 나눠야 하는 문제였다.</p>\n<p>이때는 새로운 1차원 배열인 dp가 필요하다. 우선적으로 이 배열은 문자의 개수만큼 칸이 나누어져있고 첫번째 배열 값만을 제외하고 모든 값은 <code class=\"language-text\">Infinity</code>로 저장이 된다. 이후에는 만약 board 2차원 배열의 값이 1인 경우 dp 배열의 값과 이전 인덱스의 값 +1한 값 중에서 작은 값을 선택해주면 된다. 이론적으로 설명하면 어려우니 코드로 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> dp <span class=\"token operator\">=</span> <span class=\"token function\">Array</span><span class=\"token punctuation\">(</span><span class=\"token constant\">N</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token constant\">N</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> i<span class=\"token punctuation\">;</span> j <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>board<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dp<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC\">🎯 팰린드롬</a></li>\n<li><a href=\"#-%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC%EC%9D%98-%EB%B6%84%ED%95%A0\">🎯 팰린드롬의 분할</a></li>\n</ul>\n</div>","excerpt":"🎯 팰린드롬 상당히 어려운 부분이었다. 우선적으로 이야기하자면 은 어떤 문자가 뒤집어도 대칭이 유지되는 것을 의미한다. 예를들어 ‘A’, ‘AA’, ‘ABCBA’가 팰린드롬에 해당된다. 👉 관련 문제 확인하기 : BOJ - 팰린드롬? 이것을 구현하기 위해서는 2차원 DP배열을 활용해야 한다. 순서는 상관이 없지만 i 인덱스를 문자열의 시작점, j 인덱스를 문자열의 종점이라고 둔다면 DP[i][j]는 문자열의 i번째부터 j번째까지의 팰린드롬 유무를 확인하는 작업이라고 생각하면 편하다. 여기서 주의해야할 점은 문자의 길이가 1일 때, 문자의 길이가 2일 때, 그리고 이상일 때, 총 3가지로 분류해서 DP배열에 값을 넣는 작업을 해주면 된다. 문자의 길이가 1일 때: 팰린드롬이 무조건 가능하다. 문자의 길이가 2일 때: 두글자 모두 동일한 경우에만 팰린드롬이 가능하다. 문자의 길이가 3일 때: 첫글자, 마지막 글자가 같은 경우에, 그리고 그 두 글자를 제외한 안에 있는 문자가 팰린드롬이…","frontmatter":{"date":"February 14, 2024","title":"알고리즘 연습하기 - 팰린드롬","categories":"알고리즘","author":"재오","emoji":"✏️"},"fields":{"slug":"/Pallen/"}},"next":{"id":"720d7d16-ca37-59c4-be5a-f9076a99e7fa","html":"<p>알고리즘 문제를 풀다보면 트리 관련해서 이진 트리 혹은 이진 트리 순회 문제도 많이 확인할 수 있지만 그래프의 지름을 구하는 문제도 종종 확인할 수 있다.</p>\n<p>👉 문제 확인하기 : <a href=\"https://www.acmicpc.net/problem/1167\">BOJ - 트리의 지름</a></p>\n<h2 id=\"-트리의-지름\" style=\"position:relative;\"><a href=\"#-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%A7%80%EB%A6%84\" aria-label=\" 트리의 지름 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 트리의 지름</h2>\n<p>트리의 지름 문제는 간략하게 설명하자면 하나의 노드부터 가장 멀리 떨어져있는 노드의 거리를 계산하는 문제이다. 하지만 가장 멀리 떨어져있다고 해서 트리의 leaf를 의미하는 것은 아니다. 보통 간선의 가중치를 알려주기 때문에 하나의 노드에서부터 연결된 모든 노드의 가중치의 합이 가장 큰 값이 해당 트리의 지름인 셈이다.</p>\n<p>결과적으로 트리도 그래프와 같이 <code class=\"language-text\">DFS</code>를 활용하여 최대한 갈 수 있을만큼 가며 가중치를 계산하는 방식으로 구하면 된다. 단, BFS는 최단 거리를 구할 때 많이 사용되기 때문에 이 문제에서는 DFS를 이용해야 한다.</p>\n<p>모든 노드를 반복문을 이용하여 순회하는 것은 시간초과가 발생할 확률이 높다. 아니 거의 100% 시간초과가 발생한다. 여기서 1번 노드부터 가장 가중치가 큰 노드까지를 우선적으로 계산하고, 해당 노드에서부터 DFS를 진행하게 된다면 가장 긴 트리의 지름을 구할 수 있게된다.</p>\n<p>따라서 단순히 가중치만 계산하는 것이 아니라 노드의 번호까지 입력을 해줘야 코드가 정상적으로 작동이 된다.</p>\n<h2 id=\"-해결-코드\" style=\"position:relative;\"><a href=\"#-%ED%95%B4%EA%B2%B0-%EC%BD%94%EB%93%9C\" aria-label=\" 해결 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 해결 코드</h2>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> visited <span class=\"token operator\">=</span> <span class=\"token function\">Array</span><span class=\"token punctuation\">(</span><span class=\"token constant\">N</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> max <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">node</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">dist</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token constant\">DFS</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">node<span class=\"token punctuation\">,</span> dist</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  visited<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>max<span class=\"token punctuation\">.</span>dist <span class=\"token operator\">&lt;</span> dist<span class=\"token punctuation\">)</span> max <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> node<span class=\"token punctuation\">,</span> dist <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>nextDist<span class=\"token punctuation\">,</span> nextNode<span class=\"token punctuation\">]</span> <span class=\"token keyword\">of</span> graph<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>visited<span class=\"token punctuation\">[</span>nextNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n    <span class=\"token constant\">DFS</span><span class=\"token punctuation\">(</span>nextNode<span class=\"token punctuation\">,</span> dist <span class=\"token operator\">+</span> nextDist<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token constant\">DFS</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nvisited<span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token constant\">DFS</span><span class=\"token punctuation\">(</span>max<span class=\"token punctuation\">.</span>node<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>max<span class=\"token punctuation\">.</span>dist<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%A7%80%EB%A6%84\">🎯 트리의 지름</a></li>\n<li><a href=\"#-%ED%95%B4%EA%B2%B0-%EC%BD%94%EB%93%9C\">🎯 해결 코드</a></li>\n</ul>\n</div>","frontmatter":{"date":"February 08, 2024","title":"알고리즘 연습하기 - DFS를 활용한 트리","categories":"알고리즘","author":"재오","emoji":"✏️"},"fields":{"slug":"/TreeDiameter/"}},"prev":{"id":"8510dc68-b97e-5b38-b66f-a75e2807a799","html":"<h2 id=\"-벨만-포드\" style=\"position:relative;\"><a href=\"#-%EB%B2%A8%EB%A7%8C-%ED%8F%AC%EB%93%9C\" aria-label=\" 벨만 포드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 벨만 포드</h2>\n<p><code class=\"language-text\">벨만 포드</code> 알고리즘은 유향 그래프에서 최단 경로를 계산할 때 이용되는 알고리즘이다. 하지만 의문이 든다. 이전 포스트에서 유향 그래프 최단 경로를 계산할 때 <code class=\"language-text\">다익스트라</code> 알고리즘을 사용한다고 했었기 때문이다. 하지만 벨만 포드 알고리즘이 다익스트라 알고리즘과 가장 큰 차이를 보이는 곳은 <code class=\"language-text\">가중치의 음수 여부</code> 이다.</p>\n<p>다익스트라 알고리즘은 벨만 포드 알고리즘과 동일한 작업을 수행하지만 실행속도는 더 빠르다.</p>\n<p>그렇다면 똑같이 최단 경로를 구하는 알고리즘인데 왜 가중치가 음수일 때 벨만 포드 알고리즘을 사용해야 할까? 이 질문에 답으로 아래와 같은 그래프를 한번 살펴보자.</p>\n<p><img src=\"/4694328718388078b6470a214dc83dba/image.png\" alt=\"\"></p>\n<p>만약 위 그래프에서 시작 노드가 2인 경우를 생각해보자. 만약 4에서 2로 가는 가중치가 양수이고, 다익스트라 알고리즘을 사용했을 경우 2 - 3 - 4를 순회하고 절대 2로 다시 돌아가지 않는다. 왜냐하면 가중치 합의 최소값이 2 - 3 - 4 이후에는 갱신될 수 없기 때문에 큐에는 노드 4가 남는다.</p>\n<p>하지만 4에서 2로 가는 가중치가 음수인 경우에는 합을 계산하면 계산할 수록 최소값이 되기 때문에 음의 무한대가 되는 현상이 발생한다. 따라서 이 때에는 벨만 포드 알고리즘을 사용하여 음의 사이클을 없애는 방향으로 진행되어야 한다.</p>\n<h2 id=\"-음의-사이클-감지\" style=\"position:relative;\"><a href=\"#-%EC%9D%8C%EC%9D%98-%EC%82%AC%EC%9D%B4%ED%81%B4-%EA%B0%90%EC%A7%80\" aria-label=\" 음의 사이클 감지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 음의 사이클 감지</h2>\n<p>간단하게 설명하지면 벨만 포드 알고리즘에서는 음의 사이클이 처음으로 감지된다면 최단 거리를 찾을 수 없는 반환값을 return하게 된다.</p>\n<ol>\n<li>모든 노드까지의 거리를 Infinity로 초기화하고, 출발 노드의 거리는 0으로 초기화한다.</li>\n<li>모든 간선을 탐색하여 최단 거리를 갱신한다.</li>\n<li>2번의 과정을 노드의 개수 -1번 반복한다.</li>\n<li>3번까지의 과정에서 이미 최단 거릭 갱신이 완료되어야 한다. 그렇기 때문에 만약 2번의 과정을 한번 더 수행했을 때 최단 거리가 갱신된다면 음의 사이클이 존재한다고 판단한다. 음의 사이클이 존재한다면 최단 거리를 구하는 것이 불가능함을 알려야 한다.</li>\n</ol>\n<h2 id=\"-코드-구현-과정-js\" style=\"position:relative;\"><a href=\"#-%EC%BD%94%EB%93%9C-%EA%B5%AC%ED%98%84-%EA%B3%BC%EC%A0%95-js\" aria-label=\" 코드 구현 과정 js permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯 코드 구현 과정 (JS)</h2>\n<p>👉 관련 문제 풀어보기 : <a href=\"https://www.acmicpc.net/problem/11657\">BOJ - 타임머신</a></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 시작점과 종점, 가중치가 담겨 있는 배열 생성</span>\n<span class=\"token keyword\">let</span> paths <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token constant\">M</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  paths<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>Number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 거리의 값을 갱신할 수 있는 배열 생성</span>\n<span class=\"token keyword\">let</span> distance <span class=\"token operator\">=</span> <span class=\"token function\">Array</span><span class=\"token punctuation\">(</span><span class=\"token constant\">N</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token number\">Infinity</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">BellmanFord</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">start<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">,</span> dist</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  dist<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> update <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> path<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>from<span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">,</span> weight<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> path<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dist<span class=\"token punctuation\">[</span>from<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> weight <span class=\"token operator\">&lt;</span> dist<span class=\"token punctuation\">[</span>to<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      dist<span class=\"token punctuation\">[</span>to<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> dist<span class=\"token punctuation\">[</span>from<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> weight<span class=\"token punctuation\">;</span>\n      update <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>update<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>update <span class=\"token operator\">&amp;&amp;</span> i <span class=\"token operator\">===</span> n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-%EB%B2%A8%EB%A7%8C-%ED%8F%AC%EB%93%9C\">🎯 벨만 포드</a></li>\n<li><a href=\"#-%EC%9D%8C%EC%9D%98-%EC%82%AC%EC%9D%B4%ED%81%B4-%EA%B0%90%EC%A7%80\">🎯 음의 사이클 감지</a></li>\n<li><a href=\"#-%EC%BD%94%EB%93%9C-%EA%B5%AC%ED%98%84-%EA%B3%BC%EC%A0%95-js\">🎯 코드 구현 과정 (JS)</a></li>\n</ul>\n</div>","frontmatter":{"date":"February 14, 2024","title":"알고리즘 준비하기 - 벨만 포드","categories":"알고리즘","author":"재오","emoji":"📚"},"fields":{"slug":"/BellmanFord/"}},"site":{"siteMetadata":{"siteUrl":"https://www.jaeochoiii.com","comments":{"utterances":{"repo":"jaeochoii/jaeochoii.github.io"}}}}},"pageContext":{"slug":"/Pallen/","nextSlug":"/TreeDiameter/","prevSlug":"/BellmanFord/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}