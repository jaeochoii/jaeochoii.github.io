{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/알고리즘","result":{"pageContext":{"currentCategory":"알고리즘","categories":["All","알고리즘","자바스크립트","타입스크립트","회고"],"edges":[{"node":{"id":"b6e37b2a-fba7-50b6-9135-e888bb3045bb","excerpt":"🎯 CCW  알고리즘은 3개의 점 A, B, C가 있을 때 이 점 3개를 이은 직선의 방향을 알고자 할 때 유용한 방법이다. 경우의 수는 총 시계방향, 반시계방향, 직선 3가지가 존재한다. 기하와 벡터에서 을 사용해서 구한다고 하는데 본인은 문과 수학만 배웠기에 외적에 대해 많은 문서를 읽어봐도 이해가 잘 가지 않았다. 따라서 직선의 방정식을 이용해서 이에 대해 설명하고자 한다. 💎 직선의 방정식 구하기 좌표 A(X1, X2)와 B(X2, Y2)의 직선의 방정식을 구해보자. 💎 C 대입하기 X2 - X1 값이 양수인 경우 (직선의 방향이 오른쪽인 경우) X2 - X1 값이 음수인 경우 (직선의 방향이 왼쪽인 경우) 💎 통일 시켜서 하나의 식으로 정리하기 X2 - X1 값의 양수 여부에 따라 부등호의 결과가 반대이므로 X2 - X1을 양쪽에 곱해서 부등호를 통일시킨다. 이후 X2 - X1이 양수일 때에는 곱해도 부등호가 유지되고, 음수일 경우는 곱하면 부등호가 반대로 뒤집히는 것을 …","fields":{"slug":"/CCW/"},"frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - CCW","date":"January 13, 2024"}},"next":{"fields":{"slug":"/Wallshall/"}},"previous":null},{"node":{"id":"cc99fd35-e99b-5ebc-b623-2dbf7d06b387","excerpt":"🎯 플로이드-워셜 알고리즘 모든 최단 경로를 구하는 알고리즘이다. 이후에 정리할 은 하나의 정점에서 다른 모든 정점까지의 최단 거리를 구하는 알고리즘이었다면, 플로이드-워셜 알고리즘은 한 번 실행하여 모든 노드 간 최단 경로를 구할 수 있다. 💎 플로이드-워셜 알고리즘의 과정 모든 노드 간의 최단거리를 구해야 하는 것이 의 목표이다. 따라서 2차원 인접 행렬로 구한다. 알고리즘은 여러 라운드로 구성이 되는데 라운드마다 각 경로에서 중간 노드로 사용할 수 있는 노드를 선택하고, 더 짧은 길이를 선택하여 줄이는 과정을 반복한다. [STEP 0] 그래프의 노드와 간선에 따라 최단 거리 테이블을 갱신한다.\n [STEP 1] 1번 노드를 거쳐 가는 경우를 고려하여 테이블을 갱신한다.\n [STEP 2] 2번 노드를 거쳐 가는 경우를 고려하여 테이블을 갱신한다.\n [STEP 3] 3번, 4번 노드를 거쳐 가는 경우를 고려하여 테이블을 갱신한다.\n  🎯 플로이드-워셜 알고리즘 코드 구현 (JS)…","fields":{"slug":"/Wallshall/"},"frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - 플로이드 워셜","date":"January 09, 2024"}},"next":{"fields":{"slug":"/BFS/"}},"previous":{"fields":{"slug":"/CCW/"}}},{"node":{"id":"a7c176b4-e855-5613-b211-aedeb710b935","excerpt":"🎯 BFS 는 너비 우선 탐색이라고 하며 시작 노드로부터 가까운 노드를 먼저 방문하고 멀리 떨어져있는 노드를 나중에 방문하는 탐색 방법이다. DFS는 최대한 멀리 있는 노드를 우선으로 탐색하는데, BFS는 그 반대다. 보통 BFS는 선입선출 방식인 큐 자료구조를 이용하는 것이 일반적이다. 다른 언어의 경우는 보통 내장 라이브러리에 큐를 제공하고 있지만 자바스크립트는 큐와 관련된 객체가 내장되어 있지 않다. 따라서 BFS를 이용하기 위해서는 큐 자료구조를 따로 구현해줘야 한다. 💎 BFS의 동작 방식 우선 탐색 시작 노드를 큐에 삽입하고 방문 처리한다. 다음으로 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리한다. 이 과정을 더 이상 수행할 수 없을 때까지 반복한다. 🎯 BFS 구현 (JS) 큐(Queue) 구현 코드 🎯 BFS의 시간 복잡도 BFS는 DFS와 마찬가지로 그래프가 인접 리스트로 표현되어 있으면 전체 수행시간이 O(…","fields":{"slug":"/BFS/"},"frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - BFS","date":"January 07, 2024"}},"next":{"fields":{"slug":"/DFS/"}},"previous":{"fields":{"slug":"/Wallshall/"}}},{"node":{"id":"93234af2-bc05-5c48-9204-1bea11095217","excerpt":"🎯 그래프(Graph) 그래프는 객체 사이의 연결 관계를 표현할 수 있는 자료 구조로 실제 세계의 현상이나 사물을 정점(V)과 간선(E)으로 표현한 것이다. 한마디로 그래프는 정점과 간선들의 유한집합이라고 통칭할 수 있다. 💎 그래프의 표현 방법 프로그래밍에서 그래프는 크게 2가지 방식으로 표현할 수 있는데 과 이다. 은 2차원 배열로 각 노드의 연결 관계를 표현하는 방식이다. 연결이 되어 있지 않은 노트끼리 무한의 비용이라고 작성한다. 노드에 대해 가중치가 있을 때는 가중치를 입력해주고 가중치가 없는 경우에는 1과 0으로 표기한다. 인접 행렬 방식을 사용하면 노드의 연결 관계를 담은 배열이 중앙 대각선을 기준으로 대칭을 이루게 된다. 반면 는 리스트로 그래프의 연결 관계를 표현하는 방식으로 모든 노드에 연결 정보를 차례대로 연결하여 저장한다. 노드에 대해 가중치가 있을 때는 아래와 같이 가중치를 입력해주고 가중치가 없는 경우에는 2차원 배열로 표기한다. 💎 인접 행렬과 인접 리스…","fields":{"slug":"/DFS/"},"frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - 그래프와 DFS","date":"January 06, 2024"}},"next":{"fields":{"slug":"/Greedy/"}},"previous":{"fields":{"slug":"/BFS/"}}},{"node":{"id":"016a6a1c-1d34-53ec-9b71-0c2ea3323aae","excerpt":"🎯 그리디 알고리즘 그리디 알고리즘, 즉 은 말 그대로 선택의 순간마다 눈앞에 보이는 최적의 상황만을 쫓아서 최종적인 해답에 도달하는 방법이다. 을 이용하여 문제를 해결하는 순서는 아래와 같다. 현재 상태에서의 최적의 해답을 선택한다. 선택된 해가 문제의 조건을 만족하는지 검사한다. 원래의 문제가 해결되었는지 체크하고, 해결되지 않았다면 최적의 해답을 찾는 과정으로 돌아가 위의 과정을 반복한다. 은 문제를 해결하는 과정에서 매 순간 최적이라고 생각되는 해답을 찾으며, 이를 토대로 최종 문제의 해답에 도달하는 문제 해결 방식이다. 하지만 항상 최적의 결과를 보장하지 못한다는 점을 명심해야 한다. 따라서 아래와 같이 2가지 조건을 모두 성립하지 못한다면 탐욕법을 사용하면 안된다. 앞의 선택이 이후의 선택에 영향을 주지 않는다. 문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 문제 해결 방법으로 구성된다. 은 항상 최적의 결과를 도출하는 것은 아니지만, 어느 정도 최적에 근사한 값…","fields":{"slug":"/Greedy/"},"frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - 그리디 알고리즘","date":"January 04, 2024"}},"next":{"fields":{"slug":"/DP/"}},"previous":{"fields":{"slug":"/DFS/"}}},{"node":{"id":"3cb14c7c-b7e3-5a44-b6f9-45c4e3ca7b64","excerpt":"🎯 다이나믹 프로그래밍 개념 라고도 불리는 다이나믹 프로그래밍은 명칭과 의미의 상관관계는 없다. 보통 큰 문제를 작은 문제로 나눠서 문제를 해결할 때 이용되는 알고리즘이다. 사람들에게 익숙한 예시는 피보나치 수열이 있다. 피보나치 수열 역시 를 사용하여 수열의 큰 문제를 작은 문제로 나눠서 해결하는 과정이다. 하지만 피보나치 수열과 다이나믹 프로그래밍은 개념적으로 조금 다른 점을 갖는다. 💎 피보나치 수열의 핵심 문제의 크기에 상관 없이 어떤 한 문제의 정답이 일정하다. 몇번째 피보나치 수를 구하든지에 상관없이 n번째 피보나치수는 항상 동일하다. 💎 다이나믹 프로그래밍의 핵심 각 작은 문제는 한 번만 풀어야 한다. 같은 문제는 구할 때마다 정답이 같다. 정답을 한 번 구했으면, 어딘가에 메모해놓는다. 메모하는 것을 코드에서는 배열로 구현할 수 있다. 메모한다고 해서 Memoization이라는 용어를 사용한다. 🎯 다이나믹 프로그래밍 구현 위는 일반적으로 재귀를 이용하는 피보나치 수…","fields":{"slug":"/DP/"},"frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - 다이나믹 프로그래밍","date":"January 01, 2024"}},"next":{"fields":{"slug":"/MapSet/"}},"previous":{"fields":{"slug":"/Greedy/"}}},{"node":{"id":"53b0dd88-2015-5f8d-8553-b5377120dcf2","excerpt":"🎯 우선순위 큐 우선순위 큐는 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조의 일부이며 데이터를 우선순위에 따라 처리하고 싶을 때 사용한다. 🎯 우선순위 큐의 구현 방법 크게 2가지로 분류할 수 있다. 로 구현하는 방법과 으로 구현하는 방법. 우선 배열로 구현하는 것은 구현 자체가 간단하다는 장점이 있지만 데이터를 삭제하거나 삽입해야하는 경우 모든 인덱스를 탐색해야 하는 과정이 있기 때문에 시간복잡도가 **O(N)**이 되므로 상대적으로 부족한 성능을 보여준다. 하지만 힙으로 구현하는 것은 구현 자체에서 난이도가 높지만 시간복잡도가 **O(logN)**이기 때문에 좋은 성능을 보여준다. 🎯 힙의 특징 그렇다면 힙의 특징은 무엇일까?  힙은 완전 이진 트리 자료구조이다. 완전 이진 트리란 마지막 레벨을 제외하고 모든 레벨이 모두 채워져있으며, 마지막 레벨의 모든 노드는 가능한 왼쪽에 위치한다. 즉, 루트 노드로부터 시작하여 왼쪽에서 오른쪽 자식 노드 순서대로 데이터가 순…","fields":{"slug":"/PriorityQueue/"},"frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - 우선순위 큐","date":"December 21, 2023"}},"next":{"fields":{"slug":"/TS2/"}},"previous":{"fields":{"slug":"/MapSet/"}}},{"node":{"id":"712c5bd0-bbf8-5bc3-9fcd-aa8585716a72","excerpt":"💡forEach 와 map의 정확한 차이 파악 기억해야 할 점은 map은 새로운 배열을 반환한다는 점이다. 반환 값은 단순히 버려지기 때문에 에서 반환하지 않는다. 반면 은 새로운 배열을 반환한다. 만약 함수형 프로그래밍을 선호한다면 을 사용하는 것이 더 바람직하다.  를 사용한다면 기존 Array에 영향을 주는 반면에 은 완전히 새로운 Array를 반환하기 때문에 원래의 배열을 건들지 않는다. 또한 데이터를 변경할 때 다른 메서드를 연결하는 것도 이 훨씬 수월하다. 💡 slice와 splice의 차이 파악  함수는 인자로 시작 인덱스와 종료 인덱스를 받는다. **중요한 점은 종료 인덱스는 반환에 포함시키지 않고, 원본 배열은 절대 변경되지 않는다. **  함수는 와 다르게 원본 배열을 변경시킨다. 또한 시작 인덱스부터 몇개를 삭제할 것인지, 즉 시작 인덱스와 개수를 인자로 받는다. 이 부분은 예시와 함께 살펴보자. 또한 특정 배열의 값을 제거하고 그 자리에 다른 값을 채워 넣을 …","fields":{"slug":"/Tips/"},"frontmatter":{"categories":"알고리즘","title":"기억해야할 코딩테스트 빈출 문법","date":"December 19, 2023"}},"next":{"fields":{"slug":"/EratosTenes/"}},"previous":{"fields":{"slug":"/TS1/"}}},{"node":{"id":"5ca529d9-3564-52cc-80c3-96d53cfa80e7","excerpt":"🎯 에라토스테네스의 체 백준, 프로그래머스 문제를 풀다보면 정말 많이 등장하는 유형이 바로  이다.  는 바로 소수를 찾는 방법 중 하나이다.  알고리즘의 원리는 다음과 같다. 숫자 2를 시작으로 2를 빈 곳에 적어두고, 정해진 숫자의 범위의 마지막 숫자까지 모든 2의 배수를 제거한다. 다음 숫자인 3을 빈 곳에 적어두고, 정해진 숫자의 범위의 마지막 숫자까지 모든 3의 배수를 제거한다. 4는 제거했기 때문에 다음 숫자인 5로 넘어간다. 정해진 숫자의 범위의 마지막 숫자까지 모든 5의 배수를 제거한다. 위 과정을 마지막 숫자까지 반복한다. 빈 곳에 적어둔 숫자가 소수에 해당한다. 🎯 메모리를 효율적으로 관리하는 방법 위에서 설명하는 과정을 조금 더 분석해보면 정해진 숫자의 범위의 마지막 숫자까지의 수의 제곱근까지만 반복문을 진행해 배수를 제거하면 된다. 예를 들어 120까지의 숫자를 순회하면서 소수를 찾는 과정이라면 11^2 > 120인 11까지만 배수를 제거하고, 그 이후의 모든…","fields":{"slug":"/EratosTenes/"},"frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - 에라토스테네스의 체","date":"December 19, 2023"}},"next":{"fields":{"slug":"/StackQueueDeque/"}},"previous":{"fields":{"slug":"/Tips/"}}},{"node":{"id":"91e26d8e-2e0c-5763-9a55-88d7efd335cb","excerpt":"🎯 스택(Stack) 스택은 쉽게 생각하면 박스에 물건을 차곡차곡 정리하는 형태이다. 먼저 들어간 것이 밑에 위치하기 때문에 나중에 나오게 되고, 나중에 들어간 것이 맨 위에 위치하기 때문에 먼저 나오는 형태의 자료구조이다. 때문에 스택의 모든 연산은 스택의 최상단에서 일어난다. LIFO(Last In First Out) 스택은 서로 관계가 있는 여러 작업을 연달아 수행하면서 이전의 작업 내용을 저장해 둘 필요가 있을 때 사용된다. 스택 구현 코드 (JS) 스택 시간복잡도 push: O(1) pop: O(1) 🎯 큐(Queue) 큐는 대기 줄을 생각하면 이해가 쉽다. 대기 줄에서는 먼저 들어온 사람이 먼저 나가듯 큐에서도 먼저 들어온 데이터가 먼저 나가고 나중에 들어온 데이터가 나중에 나가는 형태의 자료구조이다. 데이터의 삽입과 삭제가 큐의 양끝에서 각각 일어나므로 큐의 앞과 뒤를 명확하게 구분지을 필요가 있다. FIFO(First In First Out) 큐는 순서대로 처리해야 …","fields":{"slug":"/StackQueueDeque/"},"frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - Stack Queue Deque","date":"December 16, 2023"}},"next":{"fields":{"slug":"/AfterPrecourse/"}},"previous":{"fields":{"slug":"/EratosTenes/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}