{"componentChunkName":"component---src-templates-category-template-js","path":"/posts","result":{"pageContext":{"currentCategory":"All","edges":[{"node":{"id":"53b0dd88-2015-5f8d-8553-b5377120dcf2","excerpt":"🎯 우선순위 큐 우선순위 큐는 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조의 일부이며 데이터를 우선순위에 따라 처리하고 싶을 때 사용한다. 🎯 우선순위 큐의 구현 방법 크게 2가지로 분류할 수 있다. 로 구현하는 방법과 으로 구현하는 방법. 우선 배열로 구현하는 것은 구현 자체가 간단하다는 장점이 있지만 데이터를 삭제하거나 삽입해야하는 경우 모든 인덱스를 탐색해야 하는 과정이 있기 때문에 시간복잡도가 **O(N)**이 되므로 상대적으로 부족한 성능을 보여준다. 하지만 힙으로 구현하는 것은 구현 자체에서 난이도가 높지만 시간복잡도가 **O(logN)**이기 때문에 좋은 성능을 보여준다. 🎯 힙의 특징 그렇다면 힙의 특징은 무엇일까?  힙은 완전 이진 트리 자료구조이다. 완전 이진 트리란 마지막 레벨을 제외하고 모든 레벨이 모두 채워져있으며, 마지막 레벨의 모든 노드는 가능한 왼쪽에 위치한다. 즉, 루트 노드로부터 시작하여 왼쪽에서 오른쪽 자식 노드 순서대로 데이터가 순…","fields":{"slug":"/PriorityQueue/"},"frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - 우선순위 큐","date":"December 21, 2023"}},"next":{"fields":{"slug":"/TS2/"}},"previous":null},{"node":{"id":"aa5ca993-92ca-5fb5-9cd4-e91bf8dee082","excerpt":"자바 언어를 사용하는 친구들이랑 개발 이야기를 하다보면 정말 자주 등장하는 주제가 이었다. 자바스크립트에 이 없다는 것을 친구들은 믿지 않았다. 그게 없으면 대체 변하지 않는 값은 어떻게 저장을 하냐고…저렇게 편한 것이 없으면 개발을 어떻게 하냐고… 진짜 더욱 궁금했다. 대충 어떤 용도로 Enum을 사용하는구나 정도로만 이해하고 넘어갔다. 어짜피 자바스크립트에는 없으니까… 하지만 타입스크립트에서는 을 사용한다는 것을 듣고 이 흥분된 기분을 감출 수 없어 바로 블로깅하러 왔다. 나도 드디어 을 쓸 수 있겠구나…! 이번 기회에 Enum에 대해 한번 정리하고 넘어가고자 한다. 🎯 Enum 은 여러 값들에 미리 이름을 정의하여 열거해두고 사용하는 타입이다. 객체와 비슷하게 원하는 값을 고정시키고 사용할 때 주로 사용한다. 하지만 의문이다. 굳이 왜 을 사용하는 것일까? 자바스크립트의 객체는 key와 value 값이 변경될 수 있다는 점이 큰 단점이다. 하지만 enum은 불변한 상수의 열거…","fields":{"slug":"/TS2/"},"frontmatter":{"categories":"타입스크립트","title":"Enum 한 번 써보자","date":"December 21, 2023"}},"next":{"fields":{"slug":"/TS1/"}},"previous":{"fields":{"slug":"/PriorityQueue/"}}},{"node":{"id":"0bcbd73f-3ba9-5098-a5d0-43357534bec3","excerpt":"🎯 TS는 타입 애너테이션 방식 타입스크립트는  방식을 사용하는데 이는 변수나 상수 혹은 함수의 인자와 반환 값에 타입을 명시적으로 선언하여 어떤 타입 값이 저장될 것인지를 컴파일러에 직접 알려주는 문법이다. 사실 위의 예시에서  선언부를 제거해도 코드는 정상적으로 동작한다. 하지만 타입을 제거하면 타입스크립트 타입 시스템이 타입 추론을 하는 과정에서 어려움을 겪을 것이다. 🎯 TS는 구조적 타이핑이다 다른 언어와는 다르게 타입스크립트에서 타입을 구분하는 방식은 조금 다르다. 타입스크립트는 구조로 타입을 구분하는데 이것을 이라고 한다. 이를 예시와 함께 살펴보자. 몹시 당황스러운 코드이다. 분명 greet이라는 함수의 매개변수로 들어갈 수 있는 값은 Pet 타입으로 제한되어 있다. 그러나 타입을 따로 명시하지 않은 cat 객체를 greet 함수의 인자로 전달해도 코드는 정상적으로 실행된다. 이유는 cat 객체는 Pet 인터페이스가 가지고 있는 name 속성을 가지고 있어 pet.n…","fields":{"slug":"/TS1/"},"frontmatter":{"categories":"타입스크립트","title":"타입스크립트의 타입 시스템","date":"December 20, 2023"}},"next":{"fields":{"slug":"/Tips/"}},"previous":{"fields":{"slug":"/TS2/"}}},{"node":{"id":"712c5bd0-bbf8-5bc3-9fcd-aa8585716a72","excerpt":"💡forEach 와 map의 정확한 차이 파악 기억해야 할 점은 map은 새로운 배열을 반환한다는 점이다. 반환 값은 단순히 버려지기 때문에 에서 반환하지 않는다. 반면 은 새로운 배열을 반환한다. 만약 함수형 프로그래밍을 선호한다면 을 사용하는 것이 더 바람직하다.  를 사용한다면 기존 Array에 영향을 주는 반면에 은 완전히 새로운 Array를 반환하기 때문에 원래의 배열을 건들지 않는다. 또한 데이터를 변경할 때 다른 메서드를 연결하는 것도 이 훨씬 수월하다. 💡 slice와 splice의 차이 파악  함수는 인자로 시작 인덱스와 종료 인덱스를 받는다. **중요한 점은 종료 인덱스는 반환에 포함시키지 않고, 원본 배열은 절대 변경되지 않는다. **  함수는 와 다르게 원본 배열을 변경시킨다. 또한 시작 인덱스부터 몇개를 삭제할 것인지, 즉 시작 인덱스와 개수를 인자로 받는다. 이 부분은 예시와 함께 살펴보자. 또한 특정 배열의 값을 제거하고 그 자리에 다른 값을 채워 넣을 …","fields":{"slug":"/Tips/"},"frontmatter":{"categories":"알고리즘","title":"기억해야할 코딩테스트 빈출 문법","date":"December 19, 2023"}},"next":{"fields":{"slug":"/EratosTenes/"}},"previous":{"fields":{"slug":"/TS1/"}}},{"node":{"id":"5ca529d9-3564-52cc-80c3-96d53cfa80e7","excerpt":"🎯 에라토스테네스의 체 백준, 프로그래머스 문제를 풀다보면 정말 많이 등장하는 유형이 바로  이다.  는 바로 소수를 찾는 방법 중 하나이다.  알고리즘의 원리는 다음과 같다. 숫자 2를 시작으로 2를 빈 곳에 적어두고, 정해진 숫자의 범위의 마지막 숫자까지 모든 2의 배수를 제거한다. 다음 숫자인 3을 빈 곳에 적어두고, 정해진 숫자의 범위의 마지막 숫자까지 모든 3의 배수를 제거한다. 4는 제거했기 때문에 다음 숫자인 5로 넘어간다. 정해진 숫자의 범위의 마지막 숫자까지 모든 5의 배수를 제거한다. 위 과정을 마지막 숫자까지 반복한다. 빈 곳에 적어둔 숫자가 소수에 해당한다. 🎯 메모리를 효율적으로 관리하는 방법 위에서 설명하는 과정을 조금 더 분석해보면 정해진 숫자의 범위의 마지막 숫자까지의 수의 제곱근까지만 반복문을 진행해 배수를 제거하면 된다. 예를 들어 120까지의 숫자를 순회하면서 소수를 찾는 과정이라면 11^2 > 120인 11까지만 배수를 제거하고, 그 이후의 모든…","fields":{"slug":"/EratosTenes/"},"frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - 에라토스테네스의 체","date":"December 19, 2023"}},"next":{"fields":{"slug":"/StackQueueDeque/"}},"previous":{"fields":{"slug":"/Tips/"}}},{"node":{"id":"91e26d8e-2e0c-5763-9a55-88d7efd335cb","excerpt":"🎯 스택(Stack) 스택은 쉽게 생각하면 박스에 물건을 차곡차곡 정리하는 형태이다. 먼저 들어간 것이 밑에 위치하기 때문에 나중에 나오게 되고, 나중에 들어간 것이 맨 위에 위치하기 때문에 먼저 나오는 형태의 자료구조이다. 때문에 스택의 모든 연산은 스택의 최상단에서 일어난다. LIFO(Last In First Out) 스택은 서로 관계가 있는 여러 작업을 연달아 수행하면서 이전의 작업 내용을 저장해 둘 필요가 있을 때 사용된다. 스택 구현 코드 (JS) 스택 시간복잡도 push: O(1) pop: O(1) 🎯 큐(Queue) 큐는 대기 줄을 생각하면 이해가 쉽다. 대기 줄에서는 먼저 들어온 사람이 먼저 나가듯 큐에서도 먼저 들어온 데이터가 먼저 나가고 나중에 들어온 데이터가 나중에 나가는 형태의 자료구조이다. 데이터의 삽입과 삭제가 큐의 양끝에서 각각 일어나므로 큐의 앞과 뒤를 명확하게 구분지을 필요가 있다. FIFO(First In First Out) 큐는 순서대로 처리해야 …","fields":{"slug":"/StackQueueDeque/"},"frontmatter":{"categories":"알고리즘","title":"알고리즘 준비하기 - Stack Queue Deque","date":"December 16, 2023"}},"next":{"fields":{"slug":"/AfterPrecourse/"}},"previous":{"fields":{"slug":"/EratosTenes/"}}},{"node":{"id":"6aabacec-58ca-5d36-8354-04c7cdb477cc","excerpt":"길고 길었던 우아한테크코스의 여정이 끝이 났다. 비록 합격이라는 좋은 결과를 얻지는 못했지만, 돌이켜보면 개발자로서 많은 것을 얻었던 시간이었다. 그중에서 객체 지향과 관련해서는 4주간의 프리코스 내내 스스로를 괴롭혔다. 1주차, 2주차, 그리고 4주차까지 미션을 진행하면서 내 코드에 대해 매번 만족했었다. “그래, 이정도면 됐다! 이 정도면 객체도 잘 분리했고, 요구사항도 잘 지켜졌고, 이보다 더 나아질 수는 없다!” 그리고 코드 리뷰를 받거나 공통 피드백을 확인하면 내가 제출했던 코드가 얼마나 잘못 작성되었는지 알 수 있었다. 해당 미션에서 무언가를 잘 지켜내면, 또 다음 미션에서 잘못된 무언가가 나오고, 이게 4주간 반복되었다. 객체 지향적인 코드를 작성하는 것은 정해진 것 없이 끝이 없는 작업이라는 것을 깨달았다. 그 말은 좋은 코드에 정해진 답도 없다를 의미하는 것 같았다. 하지만 완벽은 아니더라도, 더 나은 코드는 작성할 수 있지 않을까…? 프리코스 1주차, 그리고 코드…","fields":{"slug":"/AfterPrecourse/"},"frontmatter":{"categories":"회고","title":"나의 코드는 얼마나 객체 지향적이었는가?","date":"December 13, 2023"}},"next":null,"previous":{"fields":{"slug":"/StackQueueDeque/"}}}],"categories":["All","알고리즘","타입스크립트","회고"]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}