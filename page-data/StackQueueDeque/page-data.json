{"componentChunkName":"component---src-templates-blog-template-js","path":"/StackQueueDeque/","result":{"data":{"cur":{"id":"91e26d8e-2e0c-5763-9a55-88d7efd335cb","html":"<h3 id=\"스택stack\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%83%9Dstack\" aria-label=\"스택stack permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스택(Stack)</h3>\n<p><img src=\"stack.png\" alt=\"stack.png\"></p>\n<p>스택은 쉽게 생각하면 박스에 물건을 차곡차곡 정리하는 형태이다. 먼저 들어간 것이 밑에 위치하기 때문에 나중에 나오게 되고, 나중에 들어간 것이 맨 위에 위치하기 때문에 먼저 나오는 형태의 자료구조이다. 때문에 스택의 모든 연산은 스택의 최상단에서 일어난다. LIFO(Last In First Out)</p>\n<p>스택은 서로 관계가 있는 여러 작업을 연달아 수행하면서 <strong>이전의 작업 내용을 저장해 둘 필요가 있을 때</strong> 사용된다.</p>\n<h3 id=\"스택-구현-코드-js\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%83%9D-%EA%B5%AC%ED%98%84-%EC%BD%94%EB%93%9C-js\" aria-label=\"스택 구현 코드 js permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스택 구현 코드 (JS)</h3>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">class Stack {\n  constructor() {\n    this.arr = [];\n  }\n\n  push(item) {\n    this.arr.push(item);\n  }\n\n  pop(item) {\n    return this.arr.pop();\n  }\n\n  peek() {\n    return this.arr[this.arr.length - 1];\n  }\n}</code>\n        </deckgo-highlight-code>\n<h3 id=\"스택-시간복잡도\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%83%9D-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"스택 시간복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스택 시간복잡도</h3>\n<ul>\n<li><strong>push</strong>: O(1)</li>\n<li><strong>pop</strong>: O(1)</li>\n</ul>\n<hr>\n<h3 id=\"큐queue\" style=\"position:relative;\"><a href=\"#%ED%81%90queue\" aria-label=\"큐queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>큐(Queue)</h3>\n<p><img src=\"queue.png\" alt=\"queue.png\">\n큐는 대기 줄을 생각하면 이해가 쉽다. 대기 줄에서는 먼저 들어온 사람이 먼저 나가듯 큐에서도 먼저 들어온 데이터가 먼저 나가고 나중에 들어온 데이터가 나중에 나가는 형태의 자료구조이다. 데이터의 삽입과 삭제가 큐의 양끝에서 각각 일어나므로 큐의 앞과 뒤를 명확하게 구분지을 필요가 있다. FIFO(First In First Out)</p>\n<p>큐는 <strong>순서대로 처리해야 하는 작업을 임시로 저장</strong>해두는 버퍼(buffer)로서 많이 사용된다.</p>\n<h3 id=\"큐-구현-코드-js\" style=\"position:relative;\"><a href=\"#%ED%81%90-%EA%B5%AC%ED%98%84-%EC%BD%94%EB%93%9C-js\" aria-label=\"큐 구현 코드 js permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>큐 구현 코드 (JS)</h3>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">class Queue {\n  constructor() {\n    this.arr = [];\n  }\n\n  enqueue(item) {\n    this.arr.push(item);\n  }\n\n  dequeue(item) {\n    return this.arr.shift();\n  }\n}</code>\n        </deckgo-highlight-code>\n<h3 id=\"큐-시간복잡도\" style=\"position:relative;\"><a href=\"#%ED%81%90-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"큐 시간복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>큐 시간복잡도</h3>\n<ul>\n<li><strong>push</strong>: O(1)</li>\n<li><strong>shift</strong>: O(N)</li>\n</ul>\n<hr>\n<h3 id=\"덱deque\" style=\"position:relative;\"><a href=\"#%EB%8D%B1deque\" aria-label=\"덱deque permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>덱(Deque)</h3>\n<p><img src=\"deque.png\" alt=\"deque.png\"></p>\n<p>덱은 Double Ended Queue의 약자로 큐의 양 끝이 front이면서 rear인 형태의 자료구조이다. 이 말은 큐처럼 한쪽에서만 데이터가 들어오고 한쪽으로만 데이터가 나가는 것이 아닌 양쪽 끝에서 데이터의 삭제와 삽입 모두 가능한 것이다.</p>\n<p>덱은 스케줄링이 복잡할수록 큐와 스택보다 더 나은 효율을 보여준다.</p>\n<h3 id=\"덱-구현-코드-js\" style=\"position:relative;\"><a href=\"#%EB%8D%B1-%EA%B5%AC%ED%98%84-%EC%BD%94%EB%93%9C-js\" aria-label=\"덱 구현 코드 js permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>덱 구현 코드 (JS)</h3>\n<p><code class=\"language-text\">shift</code> 와 <code class=\"language-text\">unshift</code> 를 사용한다면 쉽게 구현할 것이라고 생각하지만 자바스크립트에서 <code class=\"language-text\">shift</code> 연산자의 시간복잡도는 O(N)이기 때문에 사용하지 않는 것을 선호한다.</p>\n<blockquote>\n<p>shift 메서드는 0번째 위치의 요소를 제거하고 연이은 나머지 값들의 위치를 한칸씩 앞으로 당기기 때문에 시간복잡도가 O(N)이다. - MDN</p>\n</blockquote>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">class Dequeue {\n  constructor() {\n    this.arr = [];\n    this.front = 0;\n    this.rear = 0;\n  }\n\n  pushFront(item){\n    if(this.arr[0]) {\n      for(let i=this.arr.length; i&gt;0; i--) {\n        this.arr[i] = this.arr[i - 1];\n      }\n    }\n    this.arr[this.front] = item;\n    this.rear += 1;\n  }\n\n  pushBack(item) {\n    this.arr[this.rear++] = item;\n  }\n\n  popFront() {\n    const result = this.front &gt;= this.rear ? null : this.arr[this.front++];\n    return result;\n  }\n\n  popBack() {\n    const result = this.head &gt;= this.rear ? null : this.arr[--this.rear];\n    return result;\n  }</code>\n        </deckgo-highlight-code>","excerpt":"스택(Stack) stack.png 스택은 쉽게 생각하면 박스에 물건을 차곡차곡 정리하는 형태이다. 먼저 들어간 것이 밑에 위치하기 때문에 나중에 나오게 되고, 나중에 들어간 것이 맨 위에 위치하기 때문에 먼저 나오는 형태의 자료구조이다. 때문에 스택의 모든 연산은 스택의 최상단에서 일어난다. LIFO(Last In First Out) 스택은 서로 관계가 있는 여러 작업을 연달아 수행하면서 이전의 작업 내용을 저장해 둘 필요가 있을 때 사용된다. 스택 구현 코드 (JS) 스택 시간복잡도 push: O(1) pop: O(1) 큐(Queue) queue.png\n큐는 대기 줄을 생각하면 이해가 쉽다. 대기 줄에서는 먼저 들어온 사람이 먼저 나가듯 큐에서도 먼저 들어온 데이터가 먼저 나가고 나중에 들어온 데이터가 나중에 나가는 형태의 자료구조이다. 데이터의 삽입과 삭제가 큐의 양끝에서 각각 일어나므로 큐의 앞과 뒤를 명확하게 구분지을 필요가 있다. FIFO(First In First Ou…","frontmatter":{"date":"December 16, 2023","title":"알고리즘 준비하기 - Stack Queue Deque","categories":"알고리즘","author":"재오","emoji":"📚"},"fields":{"slug":"/StackQueueDeque/"}},"next":{"id":"6aabacec-58ca-5d36-8354-04c7cdb477cc","html":"<p>길고 길었던 우아한테크코스의 여정이 끝이 났다.</p>\n<p>비록 합격이라는 좋은 결과를 얻지는 못했지만, 돌이켜보면 개발자로서 많은 것을 얻었던 시간이었다. 그중에서 객체 지향과 관련해서는 4주간의 프리코스 내내 스스로를 괴롭혔다.</p>\n<p>1주차, 2주차, 그리고 4주차까지 미션을 진행하면서 내 코드에 대해 매번 만족했었다. <strong>“그래, 이정도면 됐다! 이 정도면 객체도 잘 분리했고, 요구사항도 잘 지켜졌고, 이보다 더 나아질 수는 없다!”</strong> 그리고 코드 리뷰를 받거나 공통 피드백을 확인하면 내가 제출했던 코드가 얼마나 잘못 작성되었는지 알 수 있었다.</p>\n<p>해당 미션에서 무언가를 잘 지켜내면, 또 다음 미션에서 잘못된 무언가가 나오고, 이게 4주간 반복되었다. 객체 지향적인 코드를 작성하는 것은 정해진 것 없이 끝이 없는 작업이라는 것을 깨달았다. 그 말은 좋은 코드에 정해진 답도 없다를 의미하는 것 같았다.</p>\n<p>하지만 완벽은 아니더라도, 더 나은 코드는 작성할 수 있지 않을까…?</p>\n<p>프리코스 1주차, 그리고 코드 리뷰 글을 읽다보면 중간중간 <code class=\"language-text\">객체지향 생활 체조 원칙</code> 이 나온다. <strong>“이 코드는 객체지향 생활 체조 원칙 ~~에 의하면 ~~이렇게 바꾸는 것이 더 낫다고 하더라고요~”</strong> 를 수도 없이 봤다.</p>\n<p>꽤 유명한 책이라 하였지만 이번 프리코스를 하면서 처음 알게 됐다. 여러 블로그의 글을 읽어보니 몇가지의 원칙으로 정리된 것을 확인할 수 있었다. 좋은 코드의 작성을 우선은 이 원칙을 기준으로 하기로 하였다. 나보다 훨씬 잘 쓰시는 분들이 많기 때문에 원칙에 대해서는 깊게 다루지는 않을 것이다. 총 4번 제출한 코드를 기준으로 무엇이 미흡했는지 한번 고민해보고자 한다.</p>\n<h2 id=\"한-메서드에-오직-한-단계의-들여-쓰기만-한다\" style=\"position:relative;\"><a href=\"#%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C%EC%97%90-%EC%98%A4%EC%A7%81-%ED%95%9C-%EB%8B%A8%EA%B3%84%EC%9D%98-%EB%93%A4%EC%97%AC-%EC%93%B0%EA%B8%B0%EB%A7%8C-%ED%95%9C%EB%8B%A4\" aria-label=\"한 메서드에 오직 한 단계의 들여 쓰기만 한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>한 메서드에 오직 한 단계의 들여 쓰기만 한다.</h2>\n<p>한 메서드가 깊어진다는 것은 하나의 메서드가 하나의 기능을 하지 못할 확률이 높다. 또한 깊이가 깊어진다는 것은 곧 가독성의 하락을 불러온다. <strong>메서드의 길이가 길어질 것 같으면 해당 메서드를 여러 개로 분리하면 해결할 수 있다.</strong> 4주차까지 유일하게 잘 지켜온 부분이라 생각이 들었지만 4주차 크리스마스 미션 <code class=\"language-text\">PromotionController</code> 에서 그 생각은 와장창 깨져버렸다.</p>\n<h3 id=\"-입력값-예외-처리-부분에서-적용-실패\" style=\"position:relative;\"><a href=\"#-%EC%9E%85%EB%A0%A5%EA%B0%92-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC-%EB%B6%80%EB%B6%84%EC%97%90%EC%84%9C-%EC%A0%81%EC%9A%A9-%EC%8B%A4%ED%8C%A8\" aria-label=\" 입력값 예외 처리 부분에서 적용 실패 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🧨 입력값 예외 처리 부분에서 적용 실패</h3>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// 크리스마스 프로모션 _ PromotionController\n...\nasync #inputVisitDate() {\n  while (true) {\n    try {\n      return await InputView.readDate();\n    } catch (error) {\n      Console.print(error.message);\n    }\n  }\n}\n...</code>\n        </deckgo-highlight-code>\n<p><em>입력값을 받고 유효성 검사한 후 예외 처리 메시지를 출력한다. 추가적으로 프로그램을 종료시키지 않고 재입력을 받아야 한다.</em></p>\n<p>전자까지는 잘 지켜졌지만, 입력값을 잘못 입력했을 때 다시 입력받는 과정이 추가되면서 메서드가 너무 깊어졌다. 처음에는 while문 대신 재귀로 함수를 받았는데, 오류 값이 지속적으로 입력될 때 차지하는 메모리의 용량이 너무 커졌다. 그래서 while문을 적용하였지만…더 나은 방법이 있을까?</p>\n<h3 id=\"-해결-방안\" style=\"position:relative;\"><a href=\"#-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EC%95%88\" aria-label=\" 해결 방안 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💎 해결 방안</h3>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">  async #inputVisitDate() {\n    let date = null;\n\n    while (date === null) {\n      date = await this.#handleInputDate();\n    }\n\n    return date;\n  }\n\n  async #handleInputDate() {\n    try {\n      return await InputView.readDate();\n    } catch (error) {\n      Console.print(error.message);\n      return null;\n    }\n  }</code>\n        </deckgo-highlight-code>\n<p>두 개의 메서드로 분리하게 된다면 위 문제를 해결할 수 있다. 사실 전반적인 코드의 길이는 길어지긴 했지만 가독성 측면에서 매우 깔끔해진 것을 확인할 수 있다.</p>\n<h2 id=\"모든-원시값은-문자열을-포장한다\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%93%A0-%EC%9B%90%EC%8B%9C%EA%B0%92%EC%9D%80-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%84-%ED%8F%AC%EC%9E%A5%ED%95%9C%EB%8B%A4\" aria-label=\"모든 원시값은 문자열을 포장한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모든 원시값은 문자열을 포장한다.</h2>\n<h3 id=\"-유지-보수-잘할-수-있겠니\" style=\"position:relative;\"><a href=\"#-%EC%9C%A0%EC%A7%80-%EB%B3%B4%EC%88%98-%EC%9E%98%ED%95%A0-%EC%88%98-%EC%9E%88%EA%B2%A0%EB%8B%88\" aria-label=\" 유지 보수 잘할 수 있겠니 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🧨 유지 보수 잘할 수 있겠니…?</h3>\n<p>텍스트만으로는 이해하기 쉽지 않다. 4주차 미션이었던 <code class=\"language-text\">크리스마스 프로모션</code> 문제를 예로 설명해보자. 우선 총 금액을 아래와 같이 새로운 변수에 할당하였다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const totalMoney = 123_000;</code>\n        </deckgo-highlight-code>\n<p>해당 금액으로 증정 상품 제공 여부도 파악해야 하고, <code class=\"language-text\">10,000</code> 원이 넘는 금액인 지도 파악해야 한다. 그러면 아래와 같은 코드가 나올 것이다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">if (totalMoney &gt;= 10_000) true;\n\nconst giveAwayCount = Math.floor(totalMoney / 25_000);</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">totalMoney</code> 변수가 이곳 저곳에서 쓰이고 있다. 만약에 <code class=\"language-text\">totalAmount</code> 값을 유효성 검사하는 곳에도 사용한다면 중복된 값을 가진 변수가 코드 곳곳에 흩어지는 현상이 발생할 것이다. 만약에 코드를 수정해야 한다면 여러 곳을 찾아봐야 해서 유지보수가 힘들어진다.</p>\n<h3 id=\"-해결-방안-1\" style=\"position:relative;\"><a href=\"#-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EC%95%88-1\" aria-label=\" 해결 방안 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💎 해결 방안</h3>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">class TotalAmount {\n  #menu;\n  #totalAmount;\n\n  constructor(menus) {\n    this.#totalAmount;\n    this.#calculateAmount(menus);\n  }\n\n  #calculateAmount(menus) {...}\n\n  getTotalAmount() {\n    return this.#totalAmount;\n  }\n\n  getGiveawayCount() {\n    return Math.floor(this.#totalAmount / NUMBER.champagne);\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>프리코스 내내 수도 없이 강조했던 능동적인 객체의 첫걸음은 행동하는 객체이다. 도메인의 역할이 오직 값만 가져오는 것이 아니라 객체에 책임과 역할을 부여하며 캡슐화하는 것이다.</p>\n<p><code class=\"language-text\">TotalAmount</code> 라는 클래스를 생성하여 원시값을 포장하였다. 해당 객체 안에서는 유효성 검사를 할 수도 있고, 총 금액 계산, 증정 메뉴 개수 카운트 등 여러 작업을 수행할 수 있다. 그리고 계산된 값만이 반환된다.</p>\n<p>변수가 여러 곳에 흩어지지 않고 해당 <code class=\"language-text\">TotalAmount</code> 클래스 안에서만 구현하여 비즈니스 로직이 하나의 객체로 응집되었다. 이정도면 충분히 능동적인 행동을 하는 객체다운 객체를 생성한 것 같다.</p>\n<h2 id=\"한-줄에-점을-하나만-찍는다\" style=\"position:relative;\"><a href=\"#%ED%95%9C-%EC%A4%84%EC%97%90-%EC%A0%90%EC%9D%84-%ED%95%98%EB%82%98%EB%A7%8C-%EC%B0%8D%EB%8A%94%EB%8B%A4\" aria-label=\"한 줄에 점을 하나만 찍는다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>한 줄에 점을 하나만 찍는다.</h2>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">User.getMoney().getGiveawayCount(); // ❌</code>\n        </deckgo-highlight-code>\n<p>위와 같이 객체에 접근할 때 <code class=\"language-text\">.</code> 을 두번 이상 찍으면 안된다.</p>\n<p>와… 이건 사실 좀 심화된 내용을 다루는 것 같아서 어려웠다. 흠… 의도한 것은 아니었지만 지난 4주간의 코드를 살펴보니 위 규칙을 어긴 코드는 없었다.</p>\n<p>처음에는 <code class=\"language-text\">.</code> 을 하나만 찍으라는 것이 map 함수나 reduce 함수를 여러 번 사용하는 것도 해당되나..? 생각했지만 객체의 결합도가 높아져 결합도가 강해지는 것을 막는 것이 목표라고 한다.</p>\n<p>흠… 이 부분에 대해서는 <code class=\"language-text\">DTO</code>를 알아야 하고 여러모로 공부할 점이 많아서 공부하고 나중에 한번에 정리 해야겠다. 🥲</p>\n<h2 id=\"모든-엔티티를-작게-유지한다\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%93%A0-%EC%97%94%ED%8B%B0%ED%8B%B0%EB%A5%BC-%EC%9E%91%EA%B2%8C-%EC%9C%A0%EC%A7%80%ED%95%9C%EB%8B%A4\" aria-label=\"모든 엔티티를 작게 유지한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모든 엔티티를 작게 유지한다.</h2>\n<p>모든 엔티티를 작게 유지한다는 것은 50줄이 넘는 클래스와, 파일이 10개 이상인 패키지를 지양하는 원칙이다. 보통 코드의 길이가 50줄이 넘는 클래스는 한 가지의 일이 아닌 그 이상의 일을 하고있을 확률이 높으며, 무슨 일을 하고 있는지도 정확히 파악이 어려워진다.</p>\n<h3 id=\"-삐빕-50줄을-초과하였습니다\" style=\"position:relative;\"><a href=\"#-%EC%82%90%EB%B9%95-50%EC%A4%84%EC%9D%84-%EC%B4%88%EA%B3%BC%ED%95%98%EC%98%80%EC%8A%B5%EB%8B%88%EB%8B%A4\" aria-label=\" 삐빕 50줄을 초과하였습니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🧨 삐빕! 50줄을 초과하였습니다</h3>\n<p>흠… 맞는 말이다. 실제로 4주차 미션에서 <code class=\"language-text\">BenefitAmount</code> 클래스는 70줄이 넘는다. 코드를 작성하면서도 너무 길다는 생각을 안한 것은 아니다. 혜택을 정리하고 계산하는 작업 자체가 코드가 길어질 수 밖에 없기 때문에 충분히 가능하다고 스스로 합리화 하였다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">class BenefitAmount {\n  #benefitList;\n  #totalAmount;\n\n  constructor(props) {...}\n\n  #calculateDDayAmount() {...}\n\n  #calculateWeekendAmount(order) {...}\n\n  #calculateWeekAmount(order) {...}\n\n  getBenefitList() {...}\n\n  getBenefitAmount() {...}\n\nexport default BenefitAmount;\n</code>\n        </deckgo-highlight-code>\n<p>기능을 제대로 구현하지도 않았는데 벌써부터 읽기 싫어진다. 2개의 클래스로 분리가 가능할 것 같아서 살펴보니 <code class=\"language-text\">BenefitAmountCalculator</code> 라는 클래스와 <code class=\"language-text\">BenefitAmountManager</code> 라는 클래스로 나누어 전자에서 계산된 값을 후자에서 상속받아 사용하면 클래스의 기능적 무게가 훨씬 가벼워질 것 같다.</p>\n<h3 id=\"-해결-방안-2\" style=\"position:relative;\"><a href=\"#-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EC%95%88-2\" aria-label=\" 해결 방안 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💎 해결 방안</h3>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// 총금액을 계산하는 클래스\nclass BenefitAmountCalculator {\n\n  #calculateGiveaway() {...}\n\n  #calculateDDayAmount() {...}\n\n  #calculateWeekendAmount(order) {...}\n\n  #calculateWeekAmount(order) {...}\n\nexport default BenefitAmount;\n</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// 총금액을 관리하는 클래스\n\nimport BenefitCalculator from &quot;./BenefitCalculator.js&quot;;\n\nclass BenefitAmountManager {\n  #benefitList;\n  #totalAmount;\n\n  constructor(props) {...}\n\n  getBenefitList() {...}\n\n  getBenefitAmount() {...}\n\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"2개를-초과하는-인스턴스-변수를-가진-클래스를-쓰지-않는다\" style=\"position:relative;\"><a href=\"#2%EA%B0%9C%EB%A5%BC-%EC%B4%88%EA%B3%BC%ED%95%98%EB%8A%94-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EB%B3%80%EC%88%98%EB%A5%BC-%EA%B0%80%EC%A7%84-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A5%BC-%EC%93%B0%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4\" aria-label=\"2개를 초과하는 인스턴스 변수를 가진 클래스를 쓰지 않는다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2개를 초과하는 인스턴스 변수를 가진 클래스를 쓰지 않는다.</h2>\n<p>인스턴스 변수가 많아질수록 클래스의 응집도는 낮아진다는 것을 의미한다. 클래스는 <code class=\"language-text\">하나의 상태를 유지하고 관리하는 것</code> 과 <code class=\"language-text\">두개의 독립된 변수를 조율</code> 하는 두가지 종류로 나뉜다고 한다. 이것은 최대한 클래스를 많이 분리하게 함으로써 응집도를 높이는 역할을 한다.</p>\n<h3 id=\"-이게-맞나-이렇게-하는게-맞아\" style=\"position:relative;\"><a href=\"#-%EC%9D%B4%EA%B2%8C-%EB%A7%9E%EB%82%98-%EC%9D%B4%EB%A0%87%EA%B2%8C-%ED%95%98%EB%8A%94%EA%B2%8C-%EB%A7%9E%EC%95%84\" aria-label=\" 이게 맞나 이렇게 하는게 맞아 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🧨 이게 맞나…? 이렇게 하는게 맞아…?</h3>\n<p>사실 이 부분도 진짜 감이 안잡힌다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">class BenefitAmount {\n  constructor(props) {\n    ...\n  }\n}\n\n#createBenefitObject({ order, event, totalAmount }) {\n  return new BenefitAmount({\n    order,\n    benefitList: event.getEvent(),\n    totalAmount,\n  });\n}</code>\n        </deckgo-highlight-code>\n<p>기존에는 인자 3개였지만, 이 원칙을 보고 최대 2개로 수정하고자 여러번 코드를 뜯어보았다. 하지만 매번 실패하였고 오랜 고민 끝에 <code class=\"language-text\">props</code> 로 인자를 묶어서 객체로 표현하였다. 생활체조 원칙도 지켜지고, 가독성 측면에서는 개선이 되었으나 아직까지 딱히 마음에 들지 않는다.</p>\n<p>인자를 2개만 받도록 계속 수정중이다…</p>\n<p><em>혹시 팁이 있으시다면… 댓글 남겨주시면 감사하겠습니다.</em></p>\n<h2 id=\"getter-setter-property를-사용하지-않는다\" style=\"position:relative;\"><a href=\"#getter-setter-property%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4\" aria-label=\"getter setter property를 사용하지 않는다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Getter, Setter, Property를 사용하지 않는다.</h2>\n<p>나왔다… 정말 고민이 많았던 <code class=\"language-text\">Getter</code> <code class=\"language-text\">Setter</code> 를 사용하지 않는 법. 물론 코드 작성에 정해진 법은 없었지만 3주차 공통 피드백에 이 말이 쓰여진 것을 봤을 때 내 코드가 한참 잘못되기는 했구나를 깨달았고 고민했던 것 같다.</p>\n<p>우선 <strong>왜 Getter를 쓰면 안될까?</strong></p>\n<p>위에서 <strong>객체는 책임을 지게 해라!</strong> 라는 말을 기억하는가? 해당 객체에게 책임이 있으면 그 책임을 다른 객체에게 미루지 않고 본인이 시켜야 하는 것이다! 물론 그 말이 <strong>모든 코드에서 Getter를 쓰지 말아야 한다는 아닌 것으로 나는 이해했다.</strong> 지양하면 좋고, 없으면 더 좋다. 아예 안쓰는 방법도 분명 존재하겠지만 현재 나는 최대한 지양하는 방향 위에 서있다.(앞으로 학습하면서 안쓰는 날이 오지 않을까..? ㅎㅎ)</p>\n<p>아래 코드를 살펴보자.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// BenefitAmount\n\nclass BenefitAmount {\n  #benefitList;\n\n  getBenefitList() {\n    if (this.#totalAmount &lt; NUMBER.benefitStandard) this.#benefitList.fill(0);\n    return this.#benefitList;\n  }\n\n  getBenefitAmount() {\n    return this.#benefitList;\n  }\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// PromotionController\n\nclass PromotionController {\n\n  const benefitAmount = new BenefitAmount().getBenefitAmount();\n\n  return benefitAmount.reduce((acc, cost) =&gt; {\n      return acc + cost;\n  }, 0);</code>\n        </deckgo-highlight-code>\n<p>과연 위 코드가 객체 지향적인 코드일까? <code class=\"language-text\">benefitAmount</code> 에서 맡을 수 있는 책임을 <code class=\"language-text\">PromotionController</code> 에 전가하여 해당 컨트롤러에서 계산이 이루어지고 값을 반환한다. 위 코드는 객체의 책임, 자율성을 무시한 코드이다.</p>\n<h3 id=\"-해결-방안-3\" style=\"position:relative;\"><a href=\"#-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EC%95%88-3\" aria-label=\" 해결 방안 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💎 해결 방안</h3>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// BenefitAmount\ngetBenefitList() {\n  if (this.#totalAmount &lt; NUMBER.benefitStandard) this.#benefitList.fill(0);\n  return this.#benefitList;\n}\n\ngetBenefitAmount() {\n  return this.getBenefitList().reduce((acc, cost) =&gt; {\n    return acc + cost;\n  }, 0);\n}\n\n// PromotionController\nreturn new BenefitAmount().getBenefitAmount();</code>\n        </deckgo-highlight-code>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<blockquote>\n<p><a href=\"https://hudi.blog/thoughtworks-anthology-object-calisthenics/\">이유와 솔루션으로 정리하는 객체지향 생활체조 원칙</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://developerfarm.wordpress.com/2012/01/26/object_calisthenics_1/\">더 나은 소프트웨어를 향한 9단계: 객체지향 생활 체조(1)</a></p>\n</blockquote>","frontmatter":{"date":"December 13, 2023","title":"나의 코드는 얼마나 객체 지향적이었는가?","categories":"회고","author":"재오","emoji":"📑"},"fields":{"slug":"/AfterPrecourse/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://www.jaeochoiii.com","comments":{"utterances":{"repo":"jaeochoii/jaeochoii.github.io"}}}}},"pageContext":{"slug":"/StackQueueDeque/","nextSlug":"/AfterPrecourse/","prevSlug":""}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}